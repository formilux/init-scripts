#!/bin/bash

# service network [<ifname>]
#     arp {on|off} : enable/disable ARP for IPv4"
#     auto {on|off} : enable/disable link speed auto-negotiation"
#     autoconf_script <path> : script to run with 'ip autoconfig' (def: /usr/libexec/ipautoconfig)"
#     bonding <param> <value> : set bonding parameter (primary, mode, updelay, downdelay, ...)"
#     bridge <interface*> : deprecated, imples type=bridge. Use type and slave instead"
#     bridge_stp {on|off} : enable/disable spanning tree protocol on bridge"
#     dhcptimeout <timeout_sec> : set timeout for ip dhcp and ip autoconfig (def: 10)"
#     duplex {half|full} : force link duplex"
#     fctl {auto|both|rx|tx|none} : enable/disable sending and processing of flow control frames"
#     ip [[addr <address>] | dhcp | autoconfig] [<args>] : set IPv4 address and mask"
#     ip [dhcp | autoconfig] : manage IPv4 address using DHCP, or only once at boot (autoconfig)"
#     ip [route <dest> <-|gw>] [<args>] : set IPv4 routes"
#     ip [{arp|neigh} <ip> {<mac>|pub}] [<args>] : set IPv4 ARP entry"
#     ip6 [addr <address6>] [<args>] : set IPv6 address"
#     ip6 [neigh <addr6> {<mac>|proxy}] [<args>] : set IPv6 neighbor (IPv6 equiv to ARP)"
#     ip6 [route <dest6> <-|gw6>] [<args>] : set IPv6 routes"
#     led <led_name> [<evt>]: show link status on this led (optionally with event type)"
#     lladdr <mac_addr> : set interface MAC address"
#     load|unload <command> <arg*> : commands to be executed when interface is brought up/down"
#     media auto|{full|fdx|100full|100fdx}|{half|hdx|100half|100hdx} (deprecated, use speed & duplex)"
#     modprobe <module> <arg*> : load this module with optional arguments"
#     mtu <mtu> : set interface MTU"
#     multicast {on|off} : enable/disable receiving of multicasts"
#     replace <old_if_name> : use and rename interface old_if_name if not found"
#     shutdown : disable this interface"
#     slave <interface*> (implies type=bonding) : specify slave interfaces for bond/bridge"
#     speed {10|100|1000|...} : set link speed"
#     sysctl <var>=<val> : set network sysctl in root instance or net.ipv4.conf.\$if for interfaces"
#     sysctl6 <var>=<val>: set net.ipv6.conf.\$if sysctl for interfaces"
#     sysset <var>=<val>: set param in sys.class.net for root or sys.class.net.\$if for interfaces"
#     type <bonding|bridge|tun|tap|wg> : specify interface type"
#     usedhcphostname [0|1] : allow to set the host name from DHCP (def: 0)"
#     vrrp instance <inst> [setting value]* : set VRRP setting for VRRP instance"
#     vrrp [id|prio|address|no-address|auth_type|passwod|garp|v2|v3|...] [...]* : see service vrrp "
#     wg fwmark <mark> : mark outgoing WG packets with this FW mark"
#     wg listen_port <port> : make WG listen on this port"
#     wg private_key <file> : the the WG private key from this file"
#     wpa_group <group> : set the 'group' WPA parameter (dev: nond)"
#     wpa_key_mgmt <key> : set the 'key_mgmt' WPA parameter (def: NONE)"
#     wpa_proto <proto*> : set the 'proto' WPA parameter (def:WPA RSN)"
#     wpa_psk <psk> : set the 'psk' WPA parameter (def: none)"
#     wpa_ssid <ssid> : set the 'ssid' WPA parameter (non-empty enables WPA)"

# Notes for IPv6 addressing: accept_ra defaults to 1 which means that an
# address and a default route may be assigned by a local default gateway for
# a given duration if forwarding=0 (default). Disable this by setting either
# accept_ra=0, accept_ra_pinfo=0 or autoconf=0. Force it even when forwarding=1
# by enabling all these and setting accept_ra=2.

# we want ALL instances to stop and restart at once
if [ "$1" = "restart" ]; then
  shift
  $0 stop  "$@"
  $0 start "$@"
  exit $?
elif [ "$1" = "reload" ]; then
  shift
  $0 flush "$@"
  $0 start "$@"
  exit $?
elif [ "$1" = "complete" ]; then
  compgen -W "help status start stop flush reload restart check list_options" "$2"
  exit 0
fi

. `dirname $0`/functions

option	ip		option_ip
option	ip6		option_ip6
option	replace		standard_option
option	usedhcphostname	boolean_option	0
option	dhcptimeout	standard_option	10
option	media		standard_option
option	duplex		standard_option
option	speed		standard_option
option	auto		standard_option
option	fctl		standard_option
option  master_type	option_alias_type
option  bonding		option_bonding
option	slave		multiple_option
option	bridge		option_bridge
option	bridge_stp	boolean_option	0
option	tunnel_type	option_alias_type
option	type	        standard_option
option	sysctl		multiple_option
option	sysctl6		multiple_option
option	sysset          multiple_option
option	modprobe 	multiple_option
option	led		option_led
option	lladdr		standard_option
option	mtu		standard_option
option	arp		boolean_option	1
option	multicast	boolean_option	1
option	shutdown	boolean_option
option	vrrp	 	multiple_option
option	load 		multiple_option
option	unload 		multiple_option
option	wg	 	option_wg
option	wpa_ssid	standard_option
option	wpa_psk		standard_option
option	wpa_group	standard_option
option	wpa_key_mgmt	standard_option
option	wpa_proto	standard_option
option	autoconf_script	standard_option	/usr/libexec/ipautoconfig

SVC_VARS="addr_list addr6_list route_list route6_list arp_list addr_idx addr6_idx route_idx rule_idx neigh6_idx route6_idx rule6_idx arp_idx ipautoconf"


function do_help {
    echo "Usage: ${0##*/} <status|start|stop|flush|reload|help>"
    echo "List of config.rc options (name, type, default value) :"
    echo "   - arp {on|off} : enable/disable ARP for IPv4"
    echo "   - auto {on|off} : enable/disable link speed auto-negotiation"
    echo "   - autoconf_script <path> : script to run with 'ip autoconfig' (def: /usr/libexec/ipautoconfig)"
    echo "   - bonding <param> <value> : set bonding parameter (primary, mode, updelay, downdelay, ...)"
    echo "   - bridge <interface*> : deprecated, imples type=bridge. Use type and slave instead"
    echo "   - bridge_stp {on|off} : enable/disable spanning tree protocol on bridge"
    echo "   - dhcptimeout <timeout_sec> : set timeout for ip dhcp and ip autoconfig (def: 10)"
    echo "   - duplex {half|full} : force link duplex"
    echo "   - fctl {auto|both|rx|tx|none} : enable/disable sending and processing of flow control frames"
    echo "   - ip [[addr <address>] | dhcp | autoconfig] [<args>] : set IPv4 address and mask"
    echo "   - ip [dhcp | autoconfig] : manage IPv4 address using DHCP, or only once at boot (autoconfig)"
    echo "   - ip [route <dest> <-|gw>] [<args>] : set IPv4 routes"
    echo "   - ip [rule] [<args>]* : add IPv4 policy rule"
    echo "   - ip [{arp|neigh} <ip> {<mac>|pub}] [<args>] : set IPv4 ARP entry"
    echo "   - ip6 [addr <address6>] [<args>] : set IPv6 address"
    echo "   - ip6 [neigh <addr6> {<mac>|proxy}] [<args>] : set IPv6 neighbor (IPv6 equiv to ARP)"
    echo "   - ip6 [route <dest6> <-|gw6>] [<args>] : set IPv6 routes"
    echo "   - ip6 [rule] [<args>]* : add IPv6 policy rule"
    echo "   - led <led_name> [<evt>]: use this LED for link status (optionally with event type)"
    echo "   - lladdr <mac_addr> : set interface MAC address"
    echo "   - load|unload <command> <arg*> : commands to be executed when interface is brought up/down"
    echo "   - media auto|{full|fdx|100full|100fdx}|{half|hdx|100half|100hdx} (deprecated, use speed & duplex)"
    echo "   - modprobe <module> <arg*> : load this module with optional arguments"
    echo "   - mtu <mtu> : set interface MTU"
    echo "   - multicast {on|off} : enable/disable receiving of multicasts"
    echo "   - replace <old_if_name> : use and rename interface old_if_name if not found"
    echo "   - shutdown : disable this interface"
    echo "   - slave <interface*> (implies type=bonding) : specify slave interfaces for bond/bridge"
    echo "   - speed {10|100|1000|...} : set link speed"
    echo "   - sysctl <var>=<val> : set network sysctl in root instance or net.ipv4.conf.\$if for interfaces"
    echo "   - sysctl6 <var>=<val>: set net.ipv6.conf.\$if sysctl for interfaces"
    echo "   - sysset <var>=<val>: set param in sys.class.net for root or sys.class.net.\$if for interfaces"
    echo "   - type <bonding|bridge|tun|tap|wg> : specify interface type"
    echo "   - usedhcphostname [0|1] : allow to set the host name from DHCP (def: 0)"
    echo "   - vrrp instance <inst> [setting value]* : set VRRP setting for VRRP instance"
    echo "   - vrrp [id|prio|address|no-address|auth_type|passwod|garp|v2|v3|...] [...]* : see service vrrp "
    echo "   - wg fwmark <mark> : mark outgoing WG packets with this FW mark"
    echo "   - wg listen_port <port> : make WG listen on this port"
    echo "   - wg private_key <file> : the the WG private key from this file"
    echo "   - wpa_group <group> : set the 'group' WPA parameter (dev: nond)"
    echo "   - wpa_key_mgmt <key> : set the 'key_mgmt' WPA parameter (def: NONE)"
    echo "   - wpa_proto <proto*> : set the 'proto' WPA parameter (def:WPA RSN)"
    echo "   - wpa_psk <psk> : set the 'psk' WPA parameter (def: none)"
    echo "   - wpa_ssid <ssid> : set the 'ssid' WPA parameter (non-empty enables WPA)"
    exit 1 
}

# changes the negociation parameters for interface $1
# usage: set_media <interface> <media>
function set_media {
    case "$2" in
	auto)
	    /sbin/mii-diag -r $1 >/dev/null 2>&1 || \
		/sbin/ethtool -s $1 autoneg on >/dev/null 2>&1
	    ;;
	full|fdx|100full|100fdx)
	    /sbin/mii-diag -F 100baseTx-FD $1 >/dev/null 2>&1 || \
		/sbin/ethtool -s $1 autoneg off speed 100 duplex full
	    ;;
	half|hdx|100half|100hdx)
	    /sbin/mii-diag -F 100baseTx-HD $1 >/dev/null 2>&1 || \
		/sbin/ethtool -s $1 autoneg off speed 100 duplex half
	    ;;
	*) /sbin/mii-diag -F $opt_media $1 >/dev/null ;;
    esac
}

# changes the negociation parameters for interface $1
# $2=speed(10|100|1000) or "-" if unchanged
# $3=duplex(half|full) or "-" if unchanged
# $4=auto(on|off) or "-" if unchanged
function set_media2 {
    local miistr speed duplex

    speed="$2"; [ "$speed" = "-" ] && speed=""
    duplex="$3"; [ "$duplex" = "-" ] && duplex=""
    if [ "$4" = "on" ] || [ -z "$speed" -a -z "$duplex" ]; then
	/sbin/mii-diag -r $1 >/dev/null 2>&1 || \
	    /sbin/ethtool -s $1 autoneg on
        [ -n "$speed" -o -n "$duplex" ] || return 0
    fi

    [ "$duplex" = "half" ] && miistr="HD" || miistr="FD"
    if [ "$speed" = "10" ]; then
	miistr=10baseT-$miistr
    else
	miistr=${speed:-100}baseTx-$miistr
    fi

    # warning: with ethtool, it's important to set auto, then speed and duplex
    # in this exact order.
    /sbin/mii-diag -F $miistr $1 >/dev/null 2>&1 || \
	/sbin/ethtool -s $1 ${4:+autoneg $4} ${speed:+speed $speed} ${duplex:+duplex $duplex}
}

function set_fctl {
    case "$2" in
	both)
	    /sbin/ethtool -A $1 autoneg off rx on tx on >/dev/null 2>&1
	    ;;
	rx)
	    /sbin/ethtool -A $1 autoneg off rx on tx off >/dev/null 2>&1
	    ;;
	tx)
	    /sbin/ethtool -A $1 autoneg off rx off tx on >/dev/null 2>&1
	    ;;
	none)
	    /sbin/ethtool -A $1 autoneg off rx off tx off >/dev/null 2>&1
	    ;;
	auto)
	    /sbin/ethtool -A $1 autoneg on rx on tx on >/dev/null 2>&1
	    ;;
    esac
}

# Enables a led trigger for a network interface if available.
# Takes the interface name on $1, the LED name in $2, and optional event in $3
# (defaults to "link"). Silently ignores non-existing interfaces, missing leds
# and missing arguments.
function set_leds {
    local intf="$1"
    local led="$2"
    local evt="${3:-link}"
    local phy

    [ -n "$intf" -a -n "$led" ] || return 0
    [ -e "/sys/class/leds/$led/trigger" ] || return 0
    [ -e "/sys/class/net/$intf/phydev" ] || return 0

    # return the phy in form name-addr
    phy=$(readlink -s "/sys/class/net/$intf/phydev" 2>/dev/null)
    [ -n "$phy" ] || return 0
    phy="${phy##*/}"
    ( echo "$phy:$evt" > "/sys/class/leds/$led/trigger" ) 2>/dev/null
    return 0
}

function fct_begin_section {
    addr_list=( )
    addr6_list=( )
    arp_list=( )
    route_list=( )
    route6_list=( )
    bonding_param=( )
    bonding_value=( )
    addr_idx=0
    addr6_idx=0
    arp_idx=0
    route_idx=0
    rule_idx=0
    neigh6_idx=0
    route6_idx=0
    rule6_idx=0
    bonding_idx=0
    ipautoconf=""
    wg_listen_port=
    wg_fwmark=
    wg_private_key=
}

# assign default values to certain options for compatibility purposes
function fct_end_section {
    if [ -z "$opt_type" -a ${#opt_slave[*]} -gt 0 ]; then
        # "slave" implies "type bonding"
        opt_type="bonding"
    fi
}

# remap "bridge" to "slave"
function option_bridge {
    if [ -z "$opt_type" ]; then
        # "bridge" implies "type bridge"
        opt_type="bridge"
    fi
    shift # skip "bridge"
    multiple_option "slave" "$*"
}

function option_bonding {
	shift
	bonding_param[$bonding_idx]="$1"
	shift
	bonding_value[$bonding_idx]="$*"
	bonding_idx=$[$bonding_idx+1]
}

# used by master_type and tunnel_type
function option_alias_type {
        opt_type="$1"
}

# usage: wg [ listen_port <port> ] | [ fwmark <mark> ] | [ private_key <path> ]
function option_wg {
    shift
    local cmd=$1
    shift
    case "$cmd" in
	listen_port)
	    wg_listen_port="$*"
	    ;;
	fwmark)
	    wg_fwmark="$*"
	    ;;
	private_key)
	    wg_private_key="$*"
	    ;;
	*)
	    echo "Unknown wg command : $cmd $*"
	    return 1
    esac
}

# usage: ip <ip> {autoconfig|addr|arp|dhcp|neigh|route|rule} ...
function option_ip {
    shift
    local cmd=$1
    shift
    case "$cmd" in
	autoconfig)
	    ipautoconf=1
	    ;;
	addr|address)
	    addr_list[$addr_idx]="$*"
	    addr_idx=$[$addr_idx+1]
	    ;;
	arp|neigh*)
	    arp_list[$arp_idx]="$*"
	    arp_idx=$[$arp_idx+1]
	    ;;
	route)
	    route_list[$route_idx]="$*"
	    route_idx=$[$route_idx+1]
	    ;;
	rule)
	    rule_list[$rule_idx]="$*"
	    rule_idx=$[$rule_idx+1]
	    ;;
	dhcp)
	    addr_list[$addr_idx]="dhcp"
	    addr_idx=$[$addr_idx+1]
	    ;;
	--disable)
	    ;;
	*)
	    echo "Unknown ip command : $cmd $*"
	    return 1
    esac
}

# usage: ip6 <ipv6> {addr|neigh|route|rule} ...
function option_ip6 {
    shift
    local cmd=$1
    shift
    case "$cmd" in
        addr|address)
            addr6_list[$addr6_idx]="$*"
            addr6_idx=$[$addr6_idx+1]
            ;;
        neigh*)
            neigh6_list[$neigh6_idx]="$*"
            neigh6_idx=$[$neigh6_idx+1]
            ;;
        route)
            route6_list[$route6_idx]="$*"
            route6_idx=$[$route6_idx+1]
            ;;
	rule)
	    rule6_list[$rule6_idx]="$*"
	    rule6_idx=$[$rule6_idx+1]
	    ;;
        --disable)
            ;;
        *)
            echo "Unknown ip command : $cmd $*"
            return 1
    esac
}

# parse "led <name> [<event>]"
function option_led {
    shift
    opt_led="$1"
    opt_led_evt="$2"
}

# used with config.rc param: cpumask <mask>
# first arg is the interface to bind. second is mask (considered in decimal by
# default but hex supported with "0x" prefix).
function cpumask_bind_iface {
	local online
	local mask
	local iface
	local c

	iface="$1"; shift
	mask="$1"; shift

	[ -n "$mask" ] || mask=0xffffffff

	online=$(cpu_online_mask)
	mask=$((mask & online))
	if [ $mask -eq 0 ]; then
		# keep only the first online CPU if none is available
		mask=$((online & ~(online - 1)))
		[ $mask -ne 0 ] || return
	fi

	c=0
	for i in $(grep -w "$iface" /proc/interrupts | cut -d: -f1) ; do
		while [ $(((mask >> c) & 1 )) -eq 0 ] ; do
			((c++))
		done

		printf "%x\n" "$((1 << c++))" > /proc/irq/$i/smp_affinity

		if [ $((mask >> c)) -eq 0 ] ; then
			c=0;
		fi
	done
}


function do_start {
    local svcname=$1
    local instname=$2
    local repl
    local arg

    if [ -z "$instname" ]; then
        # here we have no instance, it's the generic section
	echo "# Starting $svcname ..."
	arg=0
	while [ $arg -lt ${#opt_modprobe[*]} ]; do
	    if [ "${opt_modprobe[$arg]}" != "#" ]; then
		if ! modprobe ${opt_modprobe[$arg]}; then
		    echo "  ==> start $svcname : modprobe ${opt_modprobe[$arg]} failed. Trying anyway."
		fi
	    fi
	    arg=$[$arg+1]
	done

        # The sysctl refers to /proc/sys/net.
        for arg in "${opt_sysctl[@]}"; do
            local sysctl value
            sysctl="${arg%%=*}"
            sysctl="${sysctl//.//}"
            value="${arg##*=}"
            if [ -e "/proc/sys/net/$sysctl" ]; then
                echo "$value" > "/proc/sys/net/$sysctl"
            else
                echo "Non-existent network sysctl entry : $arg"
            fi
        done

	# The sysset refers to /sys/class/net.
        for arg in "${opt_sysset[@]}"; do
            local sysset value
            sysset="${arg%%=*}"
            sysset="${sysset//.//}"
            value="${arg##*=}"
            if [ -e "/sys/class/net/$sysset" ]; then
                echo "$value" > "/sys/class/net/$sysset"
            else
                echo "Non-existent network sysset entry : $arg"
            fi
        done

	arg=0
	while [ $arg -lt ${#opt_load[*]} ]; do
	    if [ "${opt_load[$arg]}" != "#" ]; then
		if ! sh -c "${opt_load[$arg]}"; then
		    echo "  ==> start $svcname : load ${opt_load[$arg]} failed. Trying anyway."
		fi
	    fi
	    arg=$[$arg+1]
	done

        arg=0
        while [ $arg -lt $rule_idx ]; do
            local args=${rule_list[$arg]}
            ip rule add ${args[*]}
            arg=$[$arg+1]
        done

	arg=0
	while [ $arg -lt $route_idx ]; do
	    local dest gw
	    dest=${route_list[$arg]%%[ 	]*}
	    gw=${route_list[$arg]#*[ 	]}	# gw and potentially other ip args
	    if [ -n "${gw##connected*}" ]; then
		ip route add $dest via $gw
	    else
		ip route add $dest ${gw#connected}
	    fi
	    arg=$[$arg+1]
	done

        arg=0
        while [ $arg -lt $rule6_idx ]; do
            local args=${rule6_list[$arg]}
            ip -6 rule add ${args[*]}
            arg=$[$arg+1]
        done

        arg=0
        while [ $arg -lt $route6_idx ]; do
            local dest gw
            dest=${route6_list[$arg]%%[  ]*}
            gw=${route6_list[$arg]#*[    ]}      # gw and potentially other ip args
            if [ -n "${gw##connected*}" ]; then
                echo ip -6 route add $dest via $gw
            else
                echo ip -6 route add $dest ${gw#connected}
            fi
            arg=$[$arg+1]
        done
	echo "  ==> start $svcname : Done."
	return $?
    fi

    #
    # below we necessarily have an instance
    #

    if [ "$opt_shutdown" = 1 ]; then
	return 0
    fi

    echo "# Starting $svcname${instname:+[$instname]} ..."
    # we only check running instances when an interface is defined
    do_status $svcname $instname > /dev/null 2>&1
    if [ $? = 0 -a "$instname" != "lo" -a $FORCE_START_STOP -eq 0 ] ; then
	echo "  ==> Service $svcname${instname:+[$instname]} already running.";
	[ $SVC_AUTO_START -eq 0 ] && echo "  ==> please use '--force' or 'restart' instead or check with 'status'."
	return 0
    fi

    # maybe we want to replace an interface (which may either exist or remain
    # unloaded yet)

    repl=${opt_replace:-$instname};
    arg=0
    while [ $arg -lt ${#opt_modprobe[*]} ]; do
	if [ "${opt_modprobe[$arg]}" != "#" ]; then
	    if ! modprobe ${opt_modprobe[$arg]}; then
		echo "  ==> start $svcname${instname:+[$instname]} : modprobe ${opt_modprobe[$arg]} failed. Trying anyway."
		# return 1
	    fi
	else
	    local err	# do not merge the assignment here, local sets $? to 0 !
	    err=`modprobe $repl 2>&1`
	    if [ $? -gt 0 ]; then
		if ! grep -q "^[ 	]*$instname:" /proc/net/dev >/dev/null 2>&1; then
		    echo "  ==> start $svcname[$instname] : modprobe $instname failed : $err. Trying anyway."
		    # return 1
		fi
	    fi
	fi
	arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt ${#opt_load[*]} ]; do
        if [ "${opt_load[$arg]}" != "#" ]; then
	    if ! sh -c "${opt_load[$arg]}"; then
	        echo "  ==> start $svcname : load ${opt_load[$arg]} failed. Trying anyway."
	    fi
        fi
        arg=$[$arg+1]
    done
    arg=0

    # create tun/tap/bridge/bonding/wg
    if [ "$opt_type" = "tun" -o "$opt_type" = "tap" ] ; then
        if ! ip tuntap add dev "$instname" mode "$opt_type"; then
            echo "  ==> create $instname : failed. Trying anyway."
        fi
    elif [ "$opt_type" = "bridge" ]; then
        ip link add $instname type bridge
        ip link set $instname up
        [ "${opt_bridge_stp}" == "1" ] && echo 1 >/sys/class/net/$instname/bridge/stp_state

        # add devices to the bridge
        if [ ${#opt_slave[*]} -gt 0 ]; then
            for arg in ${opt_slave[*]}; do
                    if ! ( $0 status $arg || \
                           ip li set dev $arg up || \
                           $0 start $arg ) >/dev/null 2>&1; then
                        echo "  ==> FAILED! need to start iface $arg before $instname"
                    else
                        ( set -- $(config get "network.$arg" led); set_leds "$arg" "$2" "$3" ) 2>/dev/null
                        if ! ip link set dev $arg master $instname; then
                            echo "  ==> Failed to add slave $arg to bridge $instname"
                        fi
                        ip addr flush dev $arg >/dev/null 2>&1
                    fi
            done
        fi
    elif [ "$opt_type" = "bonding" ]; then
        if [ -e "/sys/class" ] ; then
            if [ ! -e "/sys/class/net/bonding_masters" ] ; then
                echo -n "  ==> modprobe bonding: "
                modprobe bonding
                if [ ! -e "/sys/class/net/bonding_masters" ] ; then
                    echo "Failed!"
                else
                    echo "Done."
                fi
                # Remove default created bond"
                echo "-bond0" > /sys/class/net/bonding_masters
            fi
            echo -n "  ==> create bonding master $instname: "
            echo "+$instname" > /sys/class/net/bonding_masters
            if [ ! -e "/sys/class/net/$instname" ] ; then
                echo "Failed!"
            else
                echo "Done."
            fi
            # set bonding parameters
            arg=0
            while [ $arg -lt $bonding_idx ]; do
                if [ -e "/sys/class/net/$instname/bonding/${bonding_param[$arg]}" ] ; then
                    echo "${bonding_value[$arg]}" > "/sys/class/net/$instname/bonding/${bonding_param[$arg]}" 2>/dev/null
                else
                    echo "  ==> Bonding parameter ${bonding_param[$arg]} does not exist!"
                fi
                arg=$[$arg+1]
            done
        fi
    elif [ "$opt_type" = "wg" ]; then
        ret=1
        if ! ip link add dev "$instname" type wireguard; then
            echo "  ==> FAILED: could not create wireguard interface $instname."
        elif ! wg set "$instname" \
             ${wg_listen_port:+listen-port "$wg_listen_port"} \
             ${wg_fwmark:+fwmark "$wg_fwmark"} \
             ${wg_private_key:+private-key "$wg_private_key"}; then
            echo "  ==> FAILED: could not setup wireguard interface $instname."
        elif ! ip link set "$instname" up; then
            echo "  ==> FAILED: could not create wireguard interface $instname."
        else
            ret=0
        fi

        if [ $ret -ne 0 ]; then
            echo "  ==> start $svcname${instname:+[$instname]} : Failed."
            ip link delete dev "$instname"
            return 1
        fi
    fi

    # Create the VLAN interface if it does not exist yet.
    if ! grep -qE "^[ 	]*($instname|$repl):" /proc/net/dev >/dev/null 2>&1; then
	# A dot in an interface name means physical_if.vlanid
	# We have to create the interface now.
	if [ -z "${repl//*.*/}" ]; then
	    arg="${repl%%.*}"
	    if ( ! $0 status "$arg" && ! $0 start "$arg" ) >/dev/null 2>&1; then
		echo "  ==> FAILED! could not start slave $arg before $instname"
	    fi
	    ip link add link "$arg" name "$repl" type vlan id "${repl#*.}" >/dev/null 2>&1
	    if [ $? -gt 0 ]; then
		echo "  ==> start $svcname${instname:+[$instname]} : Failed."
		return 1
	    fi
	fi
    fi

    [ "$opt_type" = "bridge" ] || ip link set "$repl" down >/dev/null 2>&1
    ip addr flush dev "$repl" >/dev/null 2>&1

    # Rename the interface if needed.
    if [ "$repl" != "$instname" ] && \
       ! grep -q "^[ 	]*$instname:" /proc/net/dev >/dev/null 2>&1 && \
	 grep -q "^[ 	]*$repl:" /proc/net/dev >/dev/null 2>&1; then
	# if the interface appears with the old name, rename it now
	ip li set "$repl" name "$instname"
    fi

    # We do this to bind IPv4 immediately to this interface.
    # It's problematic with the 'lo' device because bringing it up with IPv4
    # bound automatically adds the address 127.0.0.1/8.
    if [ ${#opt_sysctl[@]} -gt 0 ]; then
        ip addr add 0.0.0.0 dev $instname >/dev/null 2>&1
    fi

    for arg in "${opt_sysctl[@]}"; do
        local sysctl value
        sysctl="${arg%%=*}"
        sysctl="${sysctl//.//}"
        value="${arg##*=}"
        if [ -e "/proc/sys/net/ipv4/conf/$instname/$sysctl" ]; then
            echo "$value" > "/proc/sys/net/ipv4/conf/$instname/$sysctl"
        else
            echo "Non-existent IPv4 network sysctl entry for $instname : $arg"
        fi
    done

    for arg in "${opt_sysctl6[@]}"; do
        local sysctl value
        sysctl="${arg%%=*}"
        sysctl="${sysctl//.//}"
        value="${arg##*=}"
        if [ -e "/proc/sys/net/ipv6/conf/$instname/$sysctl" ]; then
            echo "$value" > "/proc/sys/net/ipv6/conf/$instname/$sysctl"
        else
            echo "Non-existent IPv6 network sysctl entry for $instname : $arg"
        fi
    done

    for arg in "${opt_sysset[@]}"; do
        local sysset value
        sysset="${arg%%=*}"
        sysset="${sysset//.//}"
        value="${arg##*=}"
        if [ -e "/sys/class/net/$instname/$sysset" ]; then
            echo "$value" > "/sys/class/net/$instname/$sysset"
        else
            echo "Non-existent network sysset entry for $instname : $arg"
        fi
    done

    if [ "$opt_lladdr" ]; then
	ip link set $instname address $opt_lladdr
    fi

    if [ "$opt_mtu" ]; then
	ip link set $instname mtu $opt_mtu
    fi

    if [ "$opt_multicast" != 1 ]; then
	ip link set $instname multicast off
    #else
	#ip link set $instname multicast on
    fi

    if [ "$opt_arp" != 1 ]; then
	ip link set $instname arp off
    fi

    if ! ip link set $instname up; then
	echo "  ==> start $svcname${instname:+[$instname]} : Failed."
	return 1
    elif [ "$instname" = "lo" ] ; then
       ip addr del dev $instname 127.0.0.1/8 >/dev/null 2>&1
    else
       # regular interface turned up. If a LED is specified, try to activate it
       set_leds "$instname" "$opt_led" "$opt_led_evt"
    fi

    if [ -n "$cpumask" ] ; then
	    cpumask_bind_iface $instname $cpumask
    fi

    if [ "$opt_media" ]; then
	if [ -n "$opt_speed" -o -n "$opt_duplex" -o -n "$opt_auto" ]; then
	    echo " ==> Warning: option 'media' inhibits 'speed','duplex' and 'auto'."
	fi
	set_media $instname "$opt_media"
	echo "  ==> Link set to $opt_media for interface $instname"
    elif [ -n "$opt_speed" -o -n "$opt_duplex" -o -n "$opt_auto" ]; then
	set_media2 $instname "${opt_speed:--}" "${opt_duplex:--}" "${opt_auto:--}"
	echo "  ==> Link configuration changed for interface $instname"
    fi

    if [ -n "$opt_fctl" ]; then
	set_fctl "$instname" "$opt_fctl"
	echo "  ==> Flow control management set to '$opt_fctl' for interface $instname"
    fi

    if [ "${opt_type}" = "bonding" ]; then
	for arg in ${opt_slave[*]}; do
	    if ( ! $0 status "$arg" && ! $0 start "$arg" ) >/dev/null 2>&1; then
		echo "  ==> FAILED! need to start slave $arg before $instname"
                ip link set $instname down
                if [ -e /sys/class/net/bonding_masters ]; then
                    echo "-$instname" > /sys/class/net/bonding_masters
                fi
                echo "  ==> start $svcname${instname:+[$instname]} : Failed."
                return 1
            elif [ -e "/sys/class/net/$instname/bonding/slaves" ]; then
                ip li set dev "$arg" down >/dev/null 2>&1
                ip addr flush dev "$arg" >/dev/null 2>&1
                # will automatically set the device up again
                echo "+$arg" > "/sys/class/net/$instname/bonding/slaves"
            else
                ifenslave $instname $arg >/dev/null 2>&1
                ip addr flush dev $arg >/dev/null 2>&1
            fi
            # the enslaving turns the slave interface up again, we may need to
            # set the LED indicator again.
            ( set -- $(config get "network.$arg" led); set_leds "$arg" "$2" "$3" ) 2>/dev/null
        done

        if [ -e "/sys/class/net/$instname/bonding" ] ; then
            # re-set bonding parameters (some parameters like primary can not be set before slave attachement )
            arg=0
            while [ $arg -lt $bonding_idx ]; do
                if [ -e "/sys/class/net/$instname/bonding/${bonding_param[$arg]}" ] ; then
                    echo "${bonding_value[$arg]}" > "/sys/class/net/$instname/bonding/${bonding_param[$arg]}" 2>/dev/null
                fi
            arg=$[$arg+1]
            done
        fi
    fi

    if [ -e "/sys/class/net/$instname/wireless" -a -n "${opt_wpa_ssid}" ] ; then
        echo "    Configuring WPA supplicant."
        rm -f "/var/run/wpa_supplicant-$instname.conf"
        (
            echo "network={"
            echo "	ssid=\"${opt_wpa_ssid}\""
            echo "	scan_ssid=1"
            if [ -n "${opt_wpa_psk}" ]; then
                echo "	key_mgmt=WPA-PSK"
                [ -z "${opt_wpa_key_mgmt}" ] || echo "  key_mgmt=${opt_wpa_key_mgmt}"
                [ -z "${opt_wpa_group}" ]    || echo "  group=${opt_wpa_group}"
                echo "	proto=${opt_wpa_proto:-WPA RSN}"
                echo "	psk=\"${opt_wpa_psk}\""
            else
                echo "	key_mgmt=NONE"
            fi
            echo "}"
        ) > "/var/run/wpa_supplicant-${instname}.conf"
        /usr/sbin/wpa_supplicant -B -i"${instname}" -c"/var/run/wpa_supplicant-${instname}.conf" -P"/var/run/wpa_supplicant-${instname}.pid"
    fi

    if [ -n "$ipautoconf" ] ; then
        echo "    Autoconfiguring using DHCP request."
        if [ -z "${opt_autoconf_script}" -o ! -e  "${opt_autoconf_script}" ] ; then
            echo "    No valid autoconfigure script, fallback on local ip configuration."
        elif udhcpc -T 1 -t ${opt_dhcptimeout:-10} -i $instname -q -n -s ${opt_autoconf_script} >/dev/null ; then
            addr_idx=0
            route_idx=0
        else
            echo "    Autoconfigure failed, fallback on local ip configuration."
        fi
    fi

    arg=0
    while [ $arg -lt $addr_idx ]; do
	if [ "${addr_list[$arg]}" = "dhcp" ]; then
	    echo "  ==> Waiting for ip address with DHCP request ... "
	    # on some cards (eg: tg3), we need to wait a bit before
	    # using the link.
	    ethtool $instname 2>/dev/null | grep -qF 'Link detected: yes' || sleep 1
	    if [ "$opt_usedhcphostname" = 0 ]; then
	        dhcpcd -t ${opt_dhcptimeout:-10} $instname
	    else
	        dhcpcd -H -t ${opt_dhcptimeout:-10} $instname
	    fi
	    set -- $(ip addr show dev $instname | grep ' inet ')
	    if [ -n "$2" ]; then
		echo "      Device $instname has IP address $2"
	    else
		echo "      Device $instname has no IP address"
	    fi
	else
	    ip addr add dev $instname ${addr_list[$arg]}
	fi
	arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt $addr6_idx ]; do
        ip -6 addr add dev $instname ${addr6_list[$arg]}
        arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt $arp_idx ]; do
	local ip mac
	ip=${arp_list[$arg]%%[ 	]*}
	mac=${arp_list[$arg]#*[ 	]}

	# delete annoying pub entries if it exists. We don't use ip neigh here
	# because it cannot create anything if an incomplete entry exists.
	arp -i $instname -d $ip pub >/dev/null 2>&1

	if [ "$mac" = "pub" ]; then
	    arp -i $instname -Ds $ip $instname pub
	else
	    arp -i $instname -s $ip $mac
	fi
	arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt $rule_idx ]; do
	local args=${rule_list[$arg]}
	ip rule add iif $instname ${args[*]}
	arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt $route_idx ]; do
	local dest gw
	dest=${route_list[$arg]%%[ 	]*}
	gw=${route_list[$arg]#*[ 	]}	# gw and potentially other ip args
	if [ -n "${gw##connected*}" ]; then
	    ip route add $dest dev $instname via $gw
	else
	    ip route add $dest dev $instname ${gw#connected}
	fi
	arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt $neigh6_idx ]; do
        local ip mac opts
        ip=${neigh6_list[$arg]%%[ 	]*}
        mac=${neigh6_list[$arg]#*[ 	]}
        opts=
        if [ -n "${mac}" -a -z "${mac##*[ 	]*}" ]; then
                opts=${mac#*[ 	]}
                mac=${mac%%[ 	]*}
        fi

        # delete possible public entries that might exist. Note that proxy
        # entries do not appear in "ip neigh", that's a bit confusing and
        # it does complicate troubleshooting.
        ip -6 neigh del $ip dev $instname >/dev/null 2>&1

        if [ "$mac" = "proxy" ]; then
            # Note that forwarding and proxy_ndp are both needed for proxy
            # entries to work. We're not setting forwarding here as it has
            # impacts on accept_ra. It should be manually set (and often will
            # as proxy entries are generally set on routers).
            (echo 1 > /proc/sys/net/ipv6/conf/$instname/proxy_ndp) 2>/dev/null
            ip -6 neigh add dev $instname proxy $ip $opts
        else
            ip -6 neigh add dev $instname $ip lladdr $mac $opts
        fi
        arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt $rule6_idx ]; do
	local args=${rule6_list[$arg]}
	ip -6 rule add iif $instname ${args[*]}
	arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt $route6_idx ]; do
        local dest gw
        dest=${route6_list[$arg]%%[      ]*}
        gw=${route6_list[$arg]#*[        ]}      # gw and potentially other ip args
        if [ -n "${gw##connected*}" ]; then
            ip -6 route add $dest dev $instname via $gw
        else
            ip -6 route add $dest dev $instname ${gw#connected}
        fi
        arg=$[$arg+1]
    done
    echo "  ==> start $svcname${instname:+[$instname]} : Done."
}

function do_status {
    local instname=$2
    if [ "$instname" ]; then
	if ip link show $instname | grep -q UP; then
	    echo "Interface $instname is up."
	    return 0
	else
	    echo "Interface $instname is down."
	    return 1
	fi
    #else
    #	 if ip route list | grep -q dev; then
    #	     echo "Network is up."
    #	     return 0
    #	 else
    #	     echo "Network is down."
    #	     return 1
    #	 fi
    fi
    REPLY=
    return 0
}


function do_stop {
    local svcname=$1
    local instname=$2
    local arg

    if [ -z "$instname" ]; then
	echo "# Stopping $svcname ..."

	arg=0
	while [ $arg -lt ${#opt_unload[*]} ]; do
	    if [ "${opt_unload[$arg]}" != "#" ]; then
		if ! sh -c "${opt_unload[$arg]}"; then
		    echo "  ==> stop $svcname : unload ${opt_unload[$arg]} failed. Trying anyway."
		fi
	    fi
	    arg=$[$arg+1]
	done

	arg=${#opt_modprobe[*]}
	while [ $arg -gt 0 ]; do
	    arg=$[$arg-1]
	    if [ "${opt_modprobe[$arg]}" != "#" ]; then
		modprobe -r ${opt_modprobe[$arg]} >/dev/null 2>&1
	    fi
	done

	arg=0
	while [ $arg -lt $route_idx ]; do
	    ip route del ${route_list[$arg]} >/dev/null 2>&1
	    arg=$[$arg+1]
	done
	return $?
    fi

    echo "# Stopping $svcname${instname:+[$instname]} ..."

    if ! do_status $svcname $instname > /dev/null 2>&1; then
	# vlan, bridges, bonding and wg interfaces must disappear
	if [ -n "${instname//*.*/}" -a "${opt_type}" != "bridge" -a \
            "${opt_type}" != "bonding" -a "${opt_type}" != "wg" ] || \
            ! ip link show $instname >/dev/null 2>&1; then
	    echo "  ==> stop $svcname${instname:+[$instname]} : already stopped."
	    return 0
        fi
    fi

    # we may have to kill dhcpcd
    arg=0
    while [ $arg -lt $addr_idx ]; do
	if [ "${addr_list[$arg]}" = "dhcp" ]; then
	    local proc
	    for proc in $(svc_pidof dhcpcd) ; do 
		if grep -qs $instname /proc/$proc/cmdline ; then kill $proc ; fi
	    done   
	fi
	arg=$[$arg+1]
    done

    if [ -e "/var/run/wpa_supplicant-${instname}.pid" ]; then
        kill $(cat "/var/run/wpa_supplicant-${instname}.pid")
        rm -f "/var/run/wpa_supplicant-${instname}.pid"
    fi
    rm -f "/var/run/wpa_supplicant-${instname}.conf"

    arg=0
    while [ $arg -lt $route6_idx ]; do
	local dest gw
	dest=${route6_list[$arg]%%[ 	]*}
	gw=${route6_list[$arg]#*[ 	]}	# gw and potentially other ip args
	if [ -n "${gw##connected*}" ]; then
	    ip -6 route del $dest ${instname:+dev $instname} via $gw >/dev/null 2>&1
	else
	    ip -6 route del $dest ${instname:+dev $instname} ${gw#connected} >/dev/null 2>&1
	fi
	arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt $route_idx ]; do
	local dest gw
	dest=${route_list[$arg]%%[ 	]*}
	gw=${route_list[$arg]#*[ 	]}	# gw and potentially other ip args
	if [ -n "${gw##connected*}" ]; then
	    ip route del $dest ${instname:+dev $instname} via $gw >/dev/null 2>&1
	else
	    ip route del $dest ${instname:+dev $instname} ${gw#connected} >/dev/null 2>&1
	fi
	arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt $rule6_idx ]; do
	local args=${rule6_list[$arg]}
	ip -6 rule delete ${instname:+iif $instname} ${args[*]} >/dev/null 2>&1
	arg=$[$arg+1]
    done

    arg=0
    while [ $arg -lt $rule_idx ]; do
	local args=${rule_list[$arg]}
	ip rule delete ${instname:+iif $instname} ${args[*]} >/dev/null 2>&1
	arg=$[$arg+1]
    done

    ip link set $instname down >/dev/null 2>&1
    ip addr flush dev $instname >/dev/null 2>&1

    arg=0
    while [ $arg -lt ${#opt_unload[*]} ]; do
        if [ "${opt_unload[$arg]}" != "#" ]; then
	    if ! sh -c "${opt_unload[$arg]}"; then
	        echo "  ==> stop $svcname : unload ${opt_unload[$arg]} failed. Trying anyway."
	    fi
        fi
        arg=$[$arg+1]
    done

    # a dot in an interface name means physical_if.vlanid
    # We have to remove the interface now.
    [ -z "${instname//*.*/}" ] && ip link del $instname >/dev/null 2>&1

    if [ "$opt_type" = "bridge" ]; then
	for arg in ${opt_slave[*]}; do
	    $0 status "$arg" && ip li set dev $arg down >/dev/null 2>&1
            ip addr flush dev $arg >/dev/null 2>&1
	    ip link set $arg nomaster >/dev/null 2>&1
        done
    fi

    # delete tun/tap/bridge/wg
    if [ "$opt_type" = "tun" -o "$opt_type" = "tap" ] ; then
        if ! ip tuntap del dev "$instname" mode "$opt_type"; then
               echo "  ==> delete $instname : failed. Trying anyway."
        fi
    elif [ "$opt_type" = "bridge" -o "$opt_type" = "wg" ]; then
	ip link del dev "$instname"
    fi

    arg=${#opt_modprobe[*]}
    while [ $arg -gt 0 ]; do
	arg=$[$arg-1]
	if [ "${opt_modprobe[$arg]}" != "#" ]; then
	    modprobe -r ${opt_modprobe[$arg]} >/dev/null 2>&1
	else
	    modprobe -r $instname >/dev/null 2>&1
	fi
    done

    # delete bond
    if [ -e "/sys/class/net/$instname/bonding" ] ; then
	echo "-$instname" > /sys/class/net/bonding_masters
    fi
    echo "  ==> stop $svcname${instname:+[$instname]} : Done."
}


# only flushes addresses, routes routes and sets if down. doesn't remove any module
function do_flush {
    local svcname=$1
    local instname=$2
    local arg

    if [ -z "$instname" ]; then
	echo "# Flushing $svcname ..."

	arg=0
	while [ $arg -lt $route_idx ]; do
	    ip route del ${route_list[$arg]} >/dev/null 2>&1
	    arg=$[$arg+1]
	done
	return $?
    fi

    echo "# Flushing $svcname${instname:+[$instname]} ..."

    if ! do_status $svcname $instname > /dev/null 2>&1; then
	# vlan interfaces must disappear
	if [ -n "${instname//*.*/}" ] || ! ip link show $instname >/dev/null 2>&1; then
	    echo "  ==> flush $svcname${instname:+[$instname]} : already flushed."
	    return 0
        fi
    fi

    # we may have to kill dhcpcd
    arg=0
    while [ $arg -lt $addr_idx ]; do
	if [ "${addr_list[$arg]}" = "dhcp" ]; then
	    local proc
	    for proc in $(svc_pidof dhcpcd) ; do 
		if grep -qs $instname /proc/$proc/cmdline ; then kill $proc ; fi
	    done   
	fi
	arg=$[$arg+1]
    done

    ip link set $instname down >/dev/null 2>&1
    ip addr flush dev $instname >/dev/null 2>&1

    # a dot in an interface name means physical_if.vlanid
    # We have to remove the interface now.
    [ -z "${instname//*.*/}" ] && ip link del $instname >/dev/null 2>&1

    echo "  ==> flush $svcname${instname:+[$instname]} : Done."
}

load_config


