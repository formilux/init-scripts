#!/bin/bash

. `dirname $0`/functions

option	bin	reserved_option	/opt/echelog/sbin/echelogd
option  config  standard_option /etc/echelog/echelog.conf
option  runas   standard_option echelogc:daemon
option	cmdline	reserved_option	'$bin -C $opt_config'
#option	check_interval	reserved_option	60

# assign default values to options and variables before parsing the cfg file
function fct_pre_start {
    local path=$( dirname $opt_config )
    local file

    if [ ! -r $opt_config ] ; then
      echo "Can't read configuration file '$opt_config'."
      exit 1
    fi
    while read ; do
      set -- $REPLY
      if [ "$1" = Module ] ; then
        # build all directories
        for file in $( grep -i "^\(SpoolDir\|StateDir\)" $path/$(eval echo $4) \
                       | awk '{print $2}' ) ; do
          if [ -d "$file" ] ; then : 
          elif [ -L "$file" -a -d "$( readlink $file )" ] ; then :
          elif [ -e "$file" ] ; then
            echo "Wished directory '$file' isn't a directory."
            exit 1
          else 
            mkdir -p -m 700 $file || { echo "Can't create directory '$file'."; exit 1; }
            chown $opt_runas $file
          fi
        done
        # sender module initialization
        if [ "$3" = "sender" ] ; then
          valueof $path/$(eval echo $4) SpoolDir > /dev/null 2>&1
          if [ ! -e "$REPLY/spool.dat" ] ; then
            touch $REPLY/.renumbered && chown $opt_runas $REPLY/.renumbered
          fi
        fi
      fi
    done < $opt_config

    # check others directories
    for path in /var/lib/echelog/{socks,run} /var/{cache,log}/echelog ; do
      if [ ! -e $path ] ; then
        mkdir -p -m 700 $path # && chown $opt_runas $path
      fi
    done
}

function kill_pid {
    REPLY=$*
    retry=0
    while [ "$REPLY" ]; do
        retry=$[$retry+1]
        if [ $retry == 1 ] ; then 
          $(dirname $bin)/echelogctl stop && sleep 5 || break
          REPLY=`ps ho pid $REPLY`
          continue
        fi
        if [ $retry -le 3 ]; then kill -CONT $REPLY && kill -$STOP_FIRST_WITH $REPLY || break; sleep $retry
        elif [ $retry -gt 3 ]; then kill -9 $REPLY || break; sleep 1
        else break; fi
        REPLY=`ps ho pid $REPLY`
    done
}

function do_stop {
    local pname=$1
    local instname=$2
    local pid
    local retry
    shift
 
    pname=${procname:-$pname}

    # stop service from pidof data
    svc_pidof -o $$ $pname > /dev/null
    echo "# Stopping process $pname${instname:+[$instname]} (pids : $REPLY) ..."
    retry=0

    kill_pid $REPLY

    if [ "$REPLY" ]; then
        echo "  ==> stop $pname${instname:+[$instname]} Failed. (pids : $REPLY)"
        return 1
    else
        declare -F fct_post_stop >/dev/null && fct_post_stop $pname $instname
        echo "  ==> stop $pname${instname:+[$instname]} Done."
        return 0
    fi
}


function fct_post_stop {
    while read ; do
      set -- $REPLY
      if [ "$1" == Define ] ; then 
        kill_pid $( ps ho pid -C $( basename $( eval echo $3) ) )
      fi
    done < $opt_config
}


function do_status {
    local pname=$1
    local instname=$2
    local pids return=0
    shift

    pname=${procname:-$pname}
    
    # get info from pidof command
    svc_pidof -o $$ $pname > /dev/null ; pids=$REPLY
    if [ "$pids" ] ; then
      echo "Process $pname${instname:+[$instname]} running without pidfile:$pids" 
    else
      echo "Process $pname${instname:+[$instname]} stopped (no pidfile used)."
      return=1
    fi
    pids=""
    while read ; do
      set -- $REPLY
      if [ "$1" == Define ] ; then 
        pids=${pids:+$pids }$( ps ho pid -C $( basename $( eval echo $3) ) )
      fi
    done < $opt_config
    if [ "$pids" ] ; then
      echo "Children processes running pidfile:$( echo $pids )"
    fi
    return $return
}



function do_check {
    echo "$HOSTNAME $1.$2 $(date +%s) RUNNING 0 OK"
}

load_config

