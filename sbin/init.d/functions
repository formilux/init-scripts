#!/bin/bash

#
# sbin/init.d/functions - Formilux init script - version 0.3.31 - 2004-03-11
#
# Copyright (C) 2001-2003 Benoit Dolez & Willy Tarreau
#       mailto: benoit@ant-computing.com,willy@ant-computing.com
#
# This program is licenced under GPLv2 ( http://www.gnu.org/licenses/gpl.txt )

exec 3<&0

# Test for previous sourcing already in progress
declare -F reserved_bool_option > /dev/null && return

# SSHD starts this script with "-c" followed by all the parameters grouped into
# one single string. So we expand it to allow remote commands.
if [ "$1" = "-c" ]; then shift; set -- $*; fi

# Configuration file to use. Default : /etc/config.rc
export CONFIG=${CONFIG:-/etc/config.rc}

# Process name
if [ -z "${0##*/*}" ]; then
    PNAME="${0##*/}"
    PPATH="${0%/*}"
    PPATH="${PPATH:-/}"
else
    PNAME="$0"
    PPATH=.
fi
PFULLNAME=$0

# Path to startup scripts. Default : /sbin/init.d
# INIT_PATH=${INIT_PATH:-/sbin/init.d}
INIT_PATH=${INIT_PATH:-$PPATH}

# Global variable for status information. Set to "1" while processing the right
# section.
RUNNING_SECTION=

# goes "1" if at least one instance of the required service has been found
SVC_FOUND=

# no option filter
OPTION_FILTER=

# signal to use at first when stopping a service. Default: TERM
# May be changed by any init script (eg: sshd)
STOP_FIRST_WITH=TERM

# set with --force to ignore current status
FORCE_START_STOP=0

# controls wether the service is being started with --auto
SVC_AUTO_START=0

# controls whether we just want to list sections
LIST_SECTIONS=0

# controls whether we just want to list boot status
LIST_BOOT_STATUS=0

# logger util
_LOGGER=${LOGGER:-logger}

# facility for syslog message
G_FACILITY=local3

# LOG FILE
LOGFILE=/var/log/startup.log
[ -L "$LOGFILE" ] && rm -f $LOGFILE
#[ -e "$LOGFILE" ] || touch $LOGFILE && chown root:adm $LOGFILE && chmod 0640 $LOGFILE

# the scripts can list some global variables which they use and that should be
# unset after processing the service. This is to be set globally.
SVC_VARS=
svc_opts=( )
svc_vars=( )
svc_defs=( )
svc_fcts=( )
svc_nbopts=0
unset ${!svc_num_*} ${!res_kwd_*}

# this is set to $? for the first do_xxx which doesn't return 0
STATUS_RET=0

if [ -x /usr/bin/taskset ]; then
  _CPUMASK=cpumask_wrapper
elif [ -x /sbin/cpumask ]; then
  _CPUMASK=/sbin/cpumask
else
  unset _CPUMASK
fi

# abort the process after displaying an error message.
die() {
    echo $* >&2
    exit 1
}

##########################################################################
# Main entry point. It is always executed even when the file is sourced. #
##########################################################################

# It is important that this entry point sits at the top of the file because
# it provides better overall performance for quick calls.

while [ $# -gt 0 ] ; do
    case "$1" in
    -f|--file)	# use this configuration file
	export CONFIG="$2"
	shift 2 || die "Error: missing arg for --file, try --help."
	;;
    --auto)	# only start services which don't have a "no autostart" statement
	SVC_AUTO_START=1
	shift
	;;
    --force)	# force start or stop disregarding current status
	FORCE_START_STOP=1
	shift
	;;
    --list_sections)  # just list sections ("<svcname> [<section>]") then exit
	LIST_SECTIONS=1
	shift
	;;
    --list_boot)  # just list boot status
	LIST_BOOT_STATUS=1
	shift
	;;
    --filter_option)	# display only this option in list_options
	OPTION_FILTER="$2"
	shift 2 || die "Error: missing arg for --filter_option, try --help."
	;;
    -o|--option)	# force options : -o "opt=val,opt=val..."
	FORCE_OPTIONS="$2"
	shift 2 || die "Error: missing arg for --option, try --help."
	;;
    -*)
	echo "Common commands : start, stop, restart, status, check, list_options."
	echo "Global options :"
	grep $'^[ \t]*-[-a-z0-9_|]*)[ \t]*# ' $PPATH/functions | \
	    sed -e $'s/^\\([ \t]*\\)\\([^)]*\\)\\([ \t#)]*\\)\\(.*\\)/    \\2\t\t\\4/'
	echo "Other options :"
	declare -F usage > /dev/null && usage $* || \
	    echo "    -h|--help		display this help" && \
		[ "x$USAGE" != x ] && echo "$USAGE"
	exit 1
	;;
    *)
	break
	;;
    esac
done

# just list sections ("<svcname> [<section>]") then exit
# if --auto is set, only list auto-start services
if [ $LIST_SECTIONS = 1 ]; then
    awk -v onlyauto=$SVC_AUTO_START \
      'BEGIN{svc="";auto=1} \
      /^[[:blank:]]*service/ {if (svc!="" && (auto || !onlyauto)) print svc;svc=$2 ($3?" "$3:"");auto=1} \
      /^[[:blank:]]*(no|)[[:blank:]]*autostart/ {if ($1=="no" && $2=="autostart") auto=0;else if ($1=="autostart") auto=1} \
	 END{if (svc!="" && (auto || !onlyauto)) print svc}' $CONFIG
    exit 0
elif [ $LIST_BOOT_STATUS = 1 ]; then
    awk -v onlyauto=$SVC_AUTO_START 'BEGIN{svc="";auto="A"}
     /^[[:blank:]]*service/ {if (svc!="" && (auto=="A" || !onlyauto)) print auto " " svc;svc=$2 ($3?" " $3:"");auto="A"}
     /^[[:blank:]]*(no|)[[:blank:]]*autostart/ {if ($1=="no" && $2=="autostart") auto="M";else if ($1=="autostart") auto="A"}
     END{if (svc!="" && (auto=="A" || !onlyauto)) print auto " " svc}' $CONFIG
     exit 0
fi

# Assign the requested action to ACTION (first arg), and check for internal
# ones. Default action : start.
ACTION=${1:-start}; shift

# Assign the requested instances to SVC_INSTANCE. Default : ""
SVC_INSTANCE=( $* )

# After that, code jumps to the end of the file to declare a few
# default options.

########################################
#           BASIC FUNCTIONS            #
########################################
logit() {
    # echo -n "'"
    # echo "'"
    echo "  $*" >&2
    [ "${1##\#*}" -a "xG_FACILITY" != x ] && \
         $_LOGGER -p $G_FACILITY.info -t "flxi[$$].$PNAME" -- \
           "exec[$USER]: $*"
    $*
    local return=$?
    [ $return != 0 -a "xG_FACILITY" != x ] && \
         $_LOGGER -p $G_FACILITY.info -t "flxi[$$].$PNAME" -- \
           "exec.error[$USER]: $return"
    return $return
}

# returns the value for a given parameter in a config file. The value is both
# echoed and set to the REPLY variable.
# The value is found this way :
# [ \t]*<parameter>[:= \t]*<value>[#]*<comment>$

# usage: valueof CONFIGFILE PARAMETER
valueof() {
    if [ -e "$1" ]; then
        REPLY=$(sed -ne s,'^\('$'[ \t]*'"$2"$'[ \t:=]*''\)\([^#]*\).*$,\2,'p "$1")
    else
        REPLY=
    fi
    echo $REPLY
}

# returns children processes ids.
# usage: childrenpid PID ...
# Returns the PID list in $REPLY
childrenpid() {
    local found
    local pos
    local res

    res=( $(ps ahxo ppid,pid) )
    pos=0; count=${#res[*]};
    while [ $pos -lt $count ] ; do
	[ ${res[pos]} == $1 ] && found[${#found[*]}]=${res[$((pos+1))]}
	((pos+=2))
    done

    REPLY=${found[*]}
}


# Returns process id from process name only by looking at the process table.
# (ie: no pidfile used). Only processes which have ppid of 1 (or parent_pid)
# are returned. A list of pids to omit can be specified with "-o".
# If no process name is specified, all the parent's children are returned.
# if "parent_pid" is empty, then the parent's pid is not checked.
# svc_pidof [ -o "omit_pids*" ]* [ -p parent_pid ] [ PNAME ... ]
svc_pidof() {
    local omit=x
    local ppid=1
    local comm
    local found

    while [ $# -gt 0 ] ; do
	if [ "x$1" = "x-o" ] ; then omit="$omit ${2/%PPID/$$} " ; shift 2
	elif [ "x$1" = "x-p" ] ; then ppid="$2" ; shift 2
	else comm="$comm $1 " ; shift 1
	fi
    done

    #set -- "$( exec ps ahxo pid,ppid,comm )" ; set -- $( echo "$1" | awk '{ print $1,$2,$3}' )
    set -- $( ps ahxo pid,ppid,comm | awk '{ print $1,$2,$3}' )
    while [ $# -gt 0 ] ; do
	[ -z "${comm/* $3 */}" -a -n "${omit/* $1 */}" ] && [ -z "$ppid" -o "$2" = "$ppid" ] && found="$found $1"
	shift ; shift ; shift
    done
    REPLY="" && [ "$found" ] && REPLY=$found && echo $REPLY
}

# This function starts the given process in background, in a new session,
# and with all its I/O directed to /dev/null, to ensure that it will not
# block a TTY if a lazy coder didn't think appropriate to close the file
# descriptors before forking.
daemon() {
    setsid "$@" </dev/null >&0 2>&0 &
}

# run command "$1" with $2=/dev/fd/XX on stdin.
run_stdin() {
	$1 <&${2##*/}
}

######################
# EXPORTED FUNCTIONS #
######################

# this eventually remounts the filesystem hosting the directory given in the
# argument read-write.
# It returns :
#   - 0 if it was RO and has successfully been remounted RW
#   - 1 if it was already RW
#   - 2 if it could not be remounted RW

remount_rw() {
   local root
   set -- $(df $1|tail -n +2)
   root=$6
   set -- $(grep -v '^rootfs' /proc/mounts |cut -f2- -d' '|grep "^$root ")
   if [ "${3/rw//}" != "$3" ]; then
      return 1
   fi
   echo -n "    - remounting $root read-write ..."
   if remountw $root >/dev/null 2>&1; then
	echo "    => done."
	return 0
   else
	echo "    => failed."
	return 2
   fi
}

# this eventually remounts the filesystem hosting the directory given in the
# argument read-only.
# It returns :
#   - 0 if it was RW and has successfully been remounted RO
#   - 1 if it was already RO
#   - 2 if it could not be remounted RO

remount_ro() {
   local root
   set -- $(df $1|tail -n +2)
   root=$6
   set -- $(grep -v '^rootfs' /proc/mounts |cut -f2- -d' '|grep "^$root ")
   if [ "${3/ro//}" != "$3" ]; then
      return 1
   fi
   echo -n "    - remounting $root read-only ..."
   if remountr $root >/dev/null 2>&1; then
	echo "    => done."
	return 0
   else
	echo "    => failed."
	return 2
   fi
}

# this will try to unload module $1 and all modules which depend on it
recursive_rmmod() {
    local -a args
    local mod

    [ -e /proc/modules ] || return 0

    while : ; do
	args=( $(/sbin/lsmod|tail -n +2|sed "s/([^)]*)//g"|grep "^$1 "|tr -d '\[\]') )
	[ ${#args[@]} -gt 0 ] || return 0
	if [ -n "${args[3]}" ]; then
	    # there are modules to unload first
	    mod=3
	    while [ $mod -lt ${#args[@]} ]; do
		if ! recursive_rmmod ${args[$mod]}; then
		    echo "Error: could not unload module ${args[$mod]}." >&2
		    return 1
		fi
		(( mod++ ))
	    done
	elif [ "${args[2]}" = "0" ]; then
	    /sbin/modprobe -r $1
	    return $?
	else
	    # impossible to remove this module (count>0)
	    return 1
	fi
    done
}

best_effort_rmmod() {
	local i
	local mod
	local dummy
	local used
	local args
	local trash
	local -a list
	local -a modules

	[ -e /proc/modules ] || return 0

	while read mod dummy used args trash ; do
		eval usedby_${mod//-/_}=\${args//,/ }
	done < /proc/modules

	i=0
	modules=( )
	list=( )
	while : ; do
		if [ $# -eq 0 ] ; then
			if [ $i -gt 0 ] ; then
				(( i-- ))
				set -- ${list[@]}
				continue
			else
				break
			fi
		fi
		modules[${#modules[@]}]="$1"
		usedby="usedby_${1}"
		if [ -n "${!usedby}" ] ; then
			if [ "${!usedby}" != "-" ] ; then
				shift;
				list[$i]="$@"
				(( i++ ))
				set -- ${!usedby}
				continue
			fi
		fi
		shift;
	done
	/sbin/modprobe -r "${modules[@]}"
}

# returns a mask of online cpus, or 1 if the mask could not be determined
cpu_online_mask() {
	local mask
	local online
	local range
	local min
	local max

	if [ ! -r /sys/devices/system/cpu/online ]; then
		echo 1
		return 0
	fi

	mask=0
	online=$(</sys/devices/system/cpu/online)
	while [ -n "$online" ]; do
		range="$online"
		if [ -z "${online##*,*}" ]; then
			online="${online#*,}"
			range="${range%,$online}"
		else
			online=""
		fi
		min="${range%%-*}"
		max="${range##*-}"
		while [ $min -le $max ]; do
			mask="$((mask | (1 << min++)))"
		done
	done
	printf "0x%x\n" $mask
}

# Usage:
#    cpumask_wrapper [ -m <mask> ] { -p <pid> | <cmd> [<args>...] }
cpumask_wrapper() {
	local online
	local mask
	local pid

	# parse -m, -p, --, and silently ignore other args
	while [ -n "$1" ]; do
		if [ -n "${1##-*}" ]; then
			break;
		elif [ "$1" = "--" ]; then shift; break;
		elif [ "$1" = "-m" ]; then mask="$2"; shift;
		elif [ "$1" = "-p" ]; then pid="$2"; shift;
		fi
		shift
	done

	[ -n "$mask" ] || mask=0xffffffff
	online=$(cpu_online_mask)
	mask=$((mask & online))
	if [ $mask -eq 0 ]; then
		# keep only the first online CPU if none is available
		mask=$((online & ~(online - 1)))
	fi

	# taskset only supports hexadecimal masks!
	mask=$(printf "0x%x" $((mask)))

	if [ -n "$pid" ]; then
		taskset -p "$mask" "$pid"
	else
		taskset "$mask" "$@"
	fi
}

########################################
# CONFIGURATION FILE LOADING FUNCTIONS #
########################################

# All functions handling options get the option name as a first argument,
# then the rest of the line follows.

# builtin function to create a variable from an option.
# The variable name is "opt_$option" where option is the option name.
standard_option() {
    if [ "x$2" = "x--disable" ]; then
	eval "opt_$1="
    else
	local name=$1 ; shift
	eval "opt_$name='$*'"
    fi
}

# builtin function to create a variable from an option.
# The variable name is "opt_$option" where option is the option name.
boolean_option() {
    if [ "x$2" = "x--disable" ]; then
	eval "opt_$1=0"
    else
	eval "opt_$1=1"
    fi
}

# builtin function to create a variable from an option.
# The variable name is the same as the option name.
# This is mainly used for reserved options such as "bin" and "cmdline",
# or to port older startup scripts.
# The option value is NOT evaluated now, which means that cmdline can refer to
# $bin if properly quoted. Eg: cmdline '$bin -f $config'
reserved_option() {
    local name="$1"
    if [ "x$2" = "x--disable" ]; then
	eval "$name="
    else
	shift
	eval "$name='$*'"
    fi
}

# builtin function to create a boolean variable from an option.
# The variable name is the same as the option name.
# This is mainly used for reserved options such as "autostart".
reserved_bool_option() {
    if [ "x$2" = "x--disable" ]; then
	eval "$1=0"
    else
	eval "$1=1"
    fi
}

# builtin function to create a variable from an option.
# The variable name is "opt_$option" where option is the option name.
long_option() {
    if [ "x$2" = "x--disable" ]; then
	eval "opt_$1="
    else
	local optname=$1
	shift
	eval "opt_$optname='$*'"
    fi
}

# builtin function to create an array from an option.
# The variable name is "opt_$option" where option is the option name.
# The array is extended with all the args for each occurence of the option.
# If no arg is given, the option is extended with a single dash '#' so that
# we further know that it has been called.
multiple_option() {
    if [ "x$2" = "x--disable" ]; then
	# in case of multiple_option, "no <option> <args>" only
	# means that we don't want to add <args> to <option>,
	# but not that we want to clear <option>
	# eval "opt_$1=( )"
	:
    else
	local optname=$1
	shift
	if [ $# -gt 0 ]; then
	    #eval "opt_$optname=( \$opt_$optname \"$*\" )"
	    eval "opt_$optname[\${#opt_$optname[*]}]='$*'"
	else
	    # if no option is set, this reference will be lost because in fact
	    # it will be added as an empty entry in the list. So we replace it
	    # with a dash '#' to mark it as referenced.
	    eval "opt_$optname[\${#opt_$optname[*]}]='#'"
	fi
    fi
}

# default start function
# usage : do_start process_name [instance_name]
# if functions fct_pre_start() and fct_post_start() are defined, they will be
# called just before and just after the cmdline.
do_start() {
    local p=$1
    local instname=$2
    local ret
    do_status $p $instname > /dev/null 2>&1
    if [ $? = 0  -a $FORCE_START_STOP -eq 0 ] ; then
	echo "Process $p${instname:+[$instname]} already running."
	[ $SVC_AUTO_START -eq 0 ] && echo "  ==> please use '--force' or 'restart' instead or check with 'status'."
	return 0
    fi

    echo "# Starting $p${instname:+[$instname]} ..."
    ret=0
    declare -F fct_pre_start >/dev/null && { fct_pre_start $p $instname ; ret=$?; }
    [ $ret -eq 0 ] && { logit ${_CPUMASK:+${cpumask:+$_CPUMASK -m $cpumask }}$cmdline; ret=$?; }
    [ $ret -eq 0 ] && declare -F fct_post_start >/dev/null && { fct_post_start $p $instname; ret=$?; }
    [ $ret -eq 0 ] && echo "  ==> start $p${instname:+[$instname]} Done." || \
		    { echo "  ==> start $p${instname:+[$instname]} Failed." ; return 1 ; }
    return 0
}

#
# This function tries to stop the process whose pid is specified in the file
# in $1. It returns 0 if the process is stopped, or 1 if it is still running.
# There can be only one pid per pidfile.
#
# usage : do_stop_with_pidfile pidfile [process_name [instance_name]]
# if functions fct_pre_stop() and fct_post_stop() are defined, they will be
# called just before and just after a successful kill sequence.
do_stop_with_pidfile() {
    local pid
    local pids
    local pidfile=$1
    local pname=$2
    local instname=$3
    local ret

    svc_pidof -o $$ $pname > /dev/null ; pids=$REPLY

    if [ $FORCE_START_STOP -eq 0 ]; then
	if ! [ -r "$pidfile" ] || { read pid REPLY <"$pidfile"; [ -z "$pid" ]; } || ! [ -L /proc/$pid/cwd ]; then
	    echo "# Process $pname${instname:+[$instname]} already stopped (according to $pidfile)${pids:+, but check pids : $pids}"
	    # ensure that we remove stale files
	    [ -e "$pidfile" ] && echo "Removing stale pid file" && rm -f "$pidfile"
	    return 0
	fi
    fi

    valueof /proc/$pid/status Name >/dev/null ; set -- $REPLY
    if [ "$pname" -a "x$pname" != "x$1" -a $FORCE_START_STOP -eq 0 ]; then
	echo "# The pid in $pidfile points to a wrong process name ($pid:$1)${pids:+. Check $pids for $pname${instname:+[$instname]}}."
	return 1;
    fi

    echo "# Stopping $pname${instname:+[$instname]} (pid $pid according to $pidfile) ..."

    ret=0
    declare -F fct_pre_stop >/dev/null && { fct_pre_stop $pname $instname; ret=$?; }
    if [ $ret -eq 0 ]; then
	kill -CONT $pid >/dev/null 2>&1 ; kill -$STOP_FIRST_WITH $pid >/dev/null 2>&1

	set -- 0 1 2 3
	while [ -L /proc/$pid/cwd -a $# -gt 0 ] ; do
	    [ $# -eq 4 ] && echo -n '  Waiting.' || echo -n '.'
	    sleep $1
	    shift
	done
	[ $# -eq 4 ] || echo

	[ -L /proc/$pid/cwd ] && { kill -9 $pid >/dev/null 2>&1; sleep 1 ; }
	if [ ! -L /proc/$pid/cwd ]; then
	    if [ -e "$pidfile" ]; then
		echo "  --> removing stale pid file ..."
		rm -f "$pidfile"
	    fi
	else
	    ret=1
	fi
    fi
    [ $ret -eq 0 ] && declare -F fct_post_stop >/dev/null && { fct_post_stop $pname $instname; ret=$?; }
    [ $ret -eq 0 ] && echo "  ==> stop $pname${instname:+[$instname]} Done." || \
		    { echo "  ==> stop $pname${instname:+[$instname]} Failed." ; return 1; }
    return 0
}

#
# default stop function
# If a pidfile exists, it is used. Otherwise, all pids with same name which have
# init for parent will be killed.
# The function returns 0 if the process is(are) stopped, and 1 if not all could
# be stopped.
#
# usage : do_stop process_name [instance_name]
# if functions fct_pre_stop() and fct_post_stop() are defined, they will be
# called just before and just after a successful kill sequence.
do_stop() {
    local pname=$1
    local instname=$2
    local pid
    local retry
    local ret
    shift

    pname=${procname:-$pname}
    # stop service from pidfile
    [ "x$pidfile" != x ] && { do_stop_with_pidfile $pidfile $pname $instname; return $? ; }

    # stop service from pidof data
    svc_pidof -o $$ $pname > /dev/null
    if [ -z "$REPLY" ]; then
	echo "# Process $pname${instname:+[$instname]} already stopped, cleaning up..."
	declare -F fct_post_stop >/dev/null && fct_post_stop $pname $instname
	echo "  ==> stop $pname${instname:+[$instname]} Done."
	return 0
    fi
    echo "# Stopping process $pname${instname:+[$instname]} (pids : $REPLY) ..."
    retry=$REPLY; # save it temporarily
    ret=0
    declare -F fct_pre_stop >/dev/null && { fct_pre_stop $pname $instname; ret=$?; }
    REPLY=$retry; retry=1
    if [ $ret -eq 0 ]; then
	while [ "$REPLY" ]; do
	    if [ $retry -le 3 ]; then
		kill -CONT $REPLY >/dev/null 2>&1 \
		  && kill -$STOP_FIRST_WITH $REPLY >/dev/null 2>&1 \
		    || break
		[ $retry -eq 1 ] && echo -n '  Waiting.' || echo -n '.'
		sleep $retry
	    elif [ $retry -eq 4 ]; then
		kill -9 $REPLY >/dev/null 2>&1 \
		  || break
		echo -n '[killing hard]'
		sleep 1
	    else
		ret=1
		break
	    fi
	    REPLY=`ps ho pid $REPLY`
	    retry=$[$retry+1]
	done
	[ $retry -gt 0 ] && echo
    fi

    retry=$REPLY; # keep a copy
    [ $ret -eq 0 ] && declare -F fct_post_stop >/dev/null && { fct_post_stop $pname $instname; ret=$?; }
    [ $ret -eq 0 ] && echo "  ==> stop $pname${instname:+[$instname]} Done." || \
		    { echo "  ==> stop $pname${instname:+[$instname]} Failed.${retry:+ (pids : $retry)}" ; return 1; }
    return 0
}

do_trystop() {
	do_stop $@
	return 0
}

# reload only for started processes
do_reload_started() {

    if [ "x$pidfile" != x ] ; then
      kill -HUP $(<$pidfile)
    else
      do_restart "$@"

    fi
}

# we just want to reload service, default reload action is to restart
do_reload() {
    if do_status "$@" >/dev/null 2>&1 ; then
      do_reload_started "$@"
    else
      do_restart "$@"
    fi
}

# we *absolutely* want to restart the service, even if it's frozen as "defunct"
do_restart() {
    do_stop $* || ( FORCE_START_STOP=1 do_stop $* )
    do_start $*
}

# returns a basic check of the service, an returns one line of info of the form:
# <hostname> <service_name>.[instance_name] <date_in_secs>  {RUNNING|STOPPED}[,more_info] [{OK|CONFIG_CHANGED}]
# returns 0 if running.
do_check() {
    local run_stat
    local status=OK
    local ret uptime=0
    local pid

    do_status $1 $2 > /dev/null
    ret=$?
    if [ $ret -eq 0 ]; then
	if [ "$REPLY" ]; then
	    for pid in $REPLY; do
		uptime=$[$(date +%s)-$(date -d "`ps ho lstart $pid`" +%s)]
		echo "`uname -n` $1.$2 `date +%s` RUNNING $uptime $status"
	    done
	else
	    echo "`uname -n` $1.$2 `date +%s` RUNNING 0 $status"
	fi
    else
        run_stat=STOPPED
	case $ret in
	    1)  status=ALERT,nofile ;;
	    2)  status=ALERT,nopid  ;;
	    3)  status=ALERT,other  ;;
	    *)  status=ALERT        ;;
	esac
	echo "`uname -n` $1.$2 `date +%s` $run_stat $uptime $status"
    fi
    return $ret
}

# returns 0 if the process is running, 1 if the pid file does not exist,
# 2 if the pid doesn't exist anymore, 3 if it has been affected to another
# process name. If the process is running, REPLY is set to its pid.
# usage : do_status_with_pidfile pidfile [process_name [instance_name]]
do_status_with_pidfile() {
    local pidfile=$1
    local pname=$2
    local instname=$3
    local pid

    [ -r "$pidfile" ] || { echo "Process $pname${instname:+[$instname]} stopped (no pidfile present)" ; return 1 ; }
    read pid < $pidfile
    [ -L /proc/$pid/cwd ] || { echo "Process $pname${instname:+[$instname]} stopped (from pidfile)" ; return 2 ; }
    valueof /proc/$pid/status Name >/dev/null ; set -- $REPLY
    [ "$pname" -a "x$pname" = "x$1" ] || {
	echo "Process with an other name ($1,$pid) already running."
	echo "  ==> you should remove invalid pidfile $pidfile"
	return 3
    }
    childrenpid $pid > /dev/null
    echo "Process $pname${instname:+[$instname]} running : $pid ${REPLY:+($REPLY)}"
    REPLY=$pid
    return 0
}

# returns 0 if the process is running; 1 if it's stopped and there's no pid file,
# otherwise same as do_status_with_pidfile(). If the process is running, REPLY is
# set to its pid.
# usage : do_status process_name [instance_name]
do_status() {
    local pname=$1
    local instname=$2
    shift

    pname=${procname:-$pname}
    # get info from pidfile if it exist
    [ "x$pidfile" != x ] && { do_status_with_pidfile $pidfile $pname $instname; return $? ; }

    # get info from pidof command
    svc_pidof -o $$ $pname > /dev/null ; pids=$REPLY
    [ "$pids" ] && { echo "Process $pname${instname:+[$instname]} running without pidfile : $pids" ; return 0 ; }
    echo "Process $pname${instname:+[$instname]} stopped (no pidfile used)."
    return 1
}

# lists all the known options for the current service, with their default or
# assigned values. There is a double eval so that options depending on others
# are correctly resolved.
# The output format is "process_name.[instance_name] option value"
# usage : list_options process_name [instance_name]
do_list_options() {
    local i=0
    local occur=0
    local nbocc=0
    local inst="$1.$2"

    while [ $i -lt $svc_nbopts ]; do
	if [ -z "$OPTION_FILTER" -o "$OPTION_FILTER" = "${svc_opts[$i]}" ]; then


	    if [ "${svc_fcts[$i]}" = "boolean_option" -o \
		 "${svc_fcts[$i]}" = "standard_option" -o \
		 "${svc_fcts[$i]}" = "long_option" -o \
		 "${svc_fcts[$i]}" = "reserved_bool_option" -o \
		 "${svc_fcts[$i]}" = "reserved_option" ]; then
		    eval eval echo $inst ${svc_opts[$i]} \$"${svc_vars[$i]}"
	    elif [ "${svc_fcts[$i]}" = "multiple_option" ]; then
		eval nbocc='${#'"${svc_vars[$i]}"'[*]}'
		occur=0
		if [ $nbocc -eq 0 ]; then # no value, let's at least show the option name
		    eval echo $inst ${svc_opts[$i]}
		else
		    while [ $occur -lt $nbocc ]; do
			eval eval echo $inst ${svc_opts[$i]} '${'"${svc_vars[$i]}"'[$occur]}'
			occur=$[$occur+1]
		    done
		fi
	    else
		echo $inst ${svc_opts[$i]} "[defined by script]"
	    fi
	fi
	i=$[$i+1]
    done
}

# maps an option to a function. Existing options are simply overridden.
# usage: option option_name function_name [ defaults ]
option() {
    local name=$1
    local fct=$2
    local def=$3
    local opt=0
    local var_name=svc_num_$1

    # first, check if this option has already been defined, and return its
    # index, or a new one if it's new.
    opt=${!var_name}
    if [ -z "$opt" ]; then
	opt=$((svc_nbopts++))
	eval $var_name=$opt
    fi

    svc_opts[$opt]=$name
    svc_fcts[$opt]=$fct
    svc_defs[$opt]=$def
    if [ "x$fct" = "xboolean_option" -o "x$fct" = "xstandard_option" -o \
	 "x$fct" = "xlong_option" -o "x$fct" = "xmultiple_option" ]; then
	svc_vars[$opt]=opt_$name
    elif [ "x$fct" = "xreserved_option" -o \
           "x$fct" = "xreserved_bool_option" ]; then
	svc_vars[$opt]=$name
    else
	svc_vars[$opt]=""
    fi
}

# default 'service' function.
# Called as default_service svc_name [svc_instance] from load_config.
# SVC_ARGS is set from the service command line, and is used at next one.
default_service() {
    local ret
    local opt
    local val
    # skip first parameter (probably 'service')
    #shift

    # check for running selected service. We generally start in previous section.
    if [ "$RUNNING_SECTION" = 1 ]; then
	# first, we'll check wether the next service is *exactly* the same as
	# the current one, in which case they are merged, in order to avoid
	# duplicate starts (system for example)
	if [ "$PNAME" = "$1" -a "${SVC_ARGS[0]}" = "$2" ]; then
	    return
	fi

	# try to insert command-line options
	while [ -n "$FORCE_OPTIONS" ]; do  # "opt=val,opt=val..."
	    opt=${FORCE_OPTIONS%%,*}
	    val=${opt#*=}
	    opt=${opt%%=*}
	    eval $opt $val
	    if [ -n "${FORCE_OPTIONS%%*,*}" ]; then # no more ','
		break;
	    else
		FORCE_OPTIONS=${FORCE_OPTIONS#*,}
	    fi
	done

	# unset all functions which handle options to avoid conflicts with
	# commands (eg: modprobe, ip ...)
	unset -f ${svc_opts[*]}

	declare -F set_vars > /dev/null && set_vars
	# force a last eval on each reserved option so that they can refer to
	# each other. This method is faster than the double eval.
	eval "bin=\"$bin\" pidfile=\"$pidfile\" procname=\"$procname\" cmdline=\"$cmdline\"" cpumask=\"$cpumask\"

	# now if the script defines a fct_end_section() function, let's call
	# it to fix some values, or extract som from external config files.
	declare -F fct_end_section > /dev/null && fct_end_section $PNAME ${SVC_ARGS[*]}

	ret=0

	# Sections marked "no autostart" are skipped on "--auto".
	# Internal actions are only called once if the instance is not set.
	if [ "$SVC_AUTO_START" = 0 -o "$autostart" = 1 ]; then
		if [ -n "$ACT_INTERNAL" -a -z "${SVC_INSTANCE[0]}" ] ; then
			if [ -z "$ACT_DONE" ] ; then 
				( do_$ACTION $PNAME <&3- )
				ret=$?
				ACT_DONE=set
			fi
		else
			# std case
			( do_$ACTION $PNAME ${SVC_ARGS[*]} <&3- )
			ret=$?
		fi
	fi

	if [ $ret -gt 0 ]; then
	    STATUS_RET=$ret
	fi

        if [ "x$G_FACILITY" != x ] ; then
          if [ "x$ACTION" = xstart -o "x$ACTION" = xstop \
               -o "x$ACTION" = xrestart ] ; then
            if [ $ret -gt 0 ] ; then
              $_LOGGER -p $G_FACILITY.err -t flxi[$$].$PNAME -- \
                  "error[$USER]: $PNAME $ACTION ${SVC_INSTANCE[*]} = $ret"
            else
              $_LOGGER -p $G_FACILITY.info -t flxi[$$].$PNAME -- \
                  "done[$USER]: $PNAME $ACTION ${SVC_INSTANCE[*]}"
            fi
          fi
        fi
	unset -v RUNNING_SECTION SVC_ARGS bin cpumask cmdline pidfile procname $SVC_VARS
    fi

    # if service is the one wished, start it at the end
    # Note that for the first and last sections, it will be different, so we still
    # need this test.
    if test "x$1" = "x$PNAME" -a \
	    \( "x$2" = "x${SVC_INSTANCE[0]}" -o "x${SVC_INSTANCE[0]}" = "x" \) ; then
	# we can test difference between SVC_ARGS and SVC_INSTANCE
	SVC_FOUND=1
	RUNNING_SECTION=1
	shift
	SVC_ARGS=( $* )

	# reset every variable
	unset -v ${svc_vars[*]}

	# map all options to their functions, and set default vars.
	i=0
	while [ $i -lt $svc_nbopts ]; do
	    eval "${svc_opts[$i]}() { ${svc_fcts[$i]} ${svc_opts[$i]} \$* ; }"
	    if [ "${svc_vars[$i]}" ]; then
		if [ "x${svc_fcts[$i]}" != "xmultiple_option" ]; then
		    eval "${svc_vars[$i]}='${svc_defs[$i]}'"
		else
		    eval "${svc_vars[$i]}=( )"
		fi
	    fi
	    i=$[$i+1]
	done


	if [ -f "/etc/default/$PNAME.${SVC_ARGS[0]}" ] ; then
		parse_cfg < "/etc/default/$PNAME.${SVC_ARGS[0]}"
	elif [ -f "/etc/default/$PNAME" ] ; then
		parse_cfg < "/etc/default/$PNAME"
	fi

	# now if the script defines a fct_begin_section() function, let's call
	# it to preset some default values from external config files.
	unset -v $SVC_VARS
	declare -F fct_begin_section > /dev/null && fct_begin_section $PNAME ${SVC_ARGS[*]}
    fi
}

# Prepare section(s) for edit
do_getsec() {
	local svc=$1;
        local instance=$2;
	local tmpconfig="/tmp/$svc${instance:+.$instance}.sec"

	[ -e "$tmpconfig" ] && cat "$tmpconfig" && return 0

	(
	local print=0

	while : ; do
		read
		eof=$?
		[ "$eof" != "0" ] && [ -z "$REPLY" ] && break

		set -- $REPLY
		[ "$1" = "no" ] && shift ;

                if [ "$1" = "service" ] ; then
			print=0
			if [ -n "$instance" ] ; then
				[ "$2" = "$svc" -a "$3" = "$instance" ] && print=1
			else
				[ "$2" = "$svc" ] && print=1
			fi
                fi
		[ $print -eq 1 ] && echo "$REPLY"

		[ "$eof" != "0" ] && echo ""

        done
	exit 0 ) < $CONFIG

        return 0
}

# Insert edited section(s)
do_setsec() {
	local svc=$1
        local instance=$2
	local tmpconfig="/tmp/$svc${instance:+.$instance}.sec"

	do_checksec $svc $instance
	[ "$?" != "0" ] && return 1
	[ ! -e "$tmpconfig" ] && echo "No configuration to commit" >&2  && return 0

        (
        local print=1
	local found=0

        while : ; do

		read
		eof=$?
		[ "$eof" != "0" ] && [ -z "$REPLY" ] && break
		set -- $REPLY
                [ "$1" = "no" ] && shift ;

                if [ "$1" = "service" ] ; then
                        print=1
                        if [ -n "$instance" -a $found -eq 0 ] ; then
                                if [ "$2" = "$svc" -a "$3" = "$instance" ] ; then
					norm_cfg < "$tmpconfig"
					found=1
					print=0
				fi
                        elif [ $found -eq 0 ] ; then
                                if [ "$2" = "$svc" ] ; then
					norm_cfg < "$tmpconfig"
					found=1
					print=0
				fi
                        elif [ -z "$instance" ] ; then
				if [ "$2" = "$svc" ] ; then
					print=0
				fi
			fi
                fi
                [ $print -eq 1 ] && echo "$REPLY"
		# config rc need returns on last line
		[ "$eof" != "0" ] && echo ""

        done
	exit 0
	) < $CONFIG >$CONFIG.new

	if [ "$?" != "0" ] ; then
		rm -f $CONFIG.new >/dev/null 2>&1
		return 1
	fi

	mv "$CONFIG.new" "$CONFIG"
	rm -f "$tmpconfig"

        return 0
}

# Update and test edited section
do_checksec() {
	local svc=$1
	local instance=$2
	local tmpconfig="/tmp/$svc${instance:+.$instance}.sec"
	local length=-1
	local hread=0
	if [ ! -t 0 ] ; then
	        eval $(
                        IFS=""
                        header="Content-length: "
                        while read line; do
                                [ -z "$line" ] && echo "hread=1" && exit 0
                                if [ "${line:0:${#header}}" = "$header" ] ; then
                                        echo -ne "length=${line:${#header}} ; "
                                fi
                        done
                        exit 0
      		)
		if [ "$hread" = "1" ] ; then
			[ "$length" = "-1" ] && echo "Invalid configuration" >&2 && return 1
       			cat > "$tmpconfig"
			[ ! -e "$tmpconfig" ] && echo "Unable to retrieve configuration" >&2 && return 1
			[ "$length" != "$( cat $tmpconfig | wc -c )" ] && echo "Truncated configuration" >&2 && return 1
		fi
	fi

	[ ! -e "$tmpconfig" ] && echo "Configuration not modified" >&2 && return 0
	( $INIT_PATH/$svc -f $tmpconfig testsec $instance >&2 )
	[ "$?" != "0" ] && return 1

	return 0
}


# Cancel section(s) edit
do_cancelsec() {
	local svc=$1
	local instance=$2
	local tmpconfig="/tmp/$svc${instance:+.$instance}.sec"
	rm -f "$tmpconfig" >/dev/null 2>&1

	return 0
}

# function to test sections on -f <config>
# unknown option for service or other services are reported as errors
do_testsec() {
	local svc=$1
	local instance=$2

        for func in $DEFINED_FUNCTIONS ; do unset -f $func ; done
	i=0
	while [ $i -lt $svc_nbopts ]; do
         	eval "function ${svc_opts[$i]} { ${svc_fcts[$i]} ${svc_opts[$i]} \$* ; } "
  		i=$[$i+1]
	done

	eval "function service { [ "x\$1" != "x$svc" ] && return 1 ; [ "x$instance" != "x" -a "x$instance" != "x\$2" ] && return 1 ; return 0 ; } "

	(
	  local func
    	  local found=0

          while : ; do

		read
		[ "$?" != "0" ] && [ -z "$REPLY" ] && break
		set -- $REPLY

       		if [ -n "$1" -a "${1:0:1}" != "#" -a "${1:0:1}" != "." ] ; then

			[ "$1" = "no" ] && shift ;
			func="$1" ; shift;

			if [ "$IGNORE_OTHERS" = "" ] ; then
			# control if first word correspond to function
				if [ -z "$func" -o -n "${func//[[:word:]]}" ] ||
				   ! declare -F "$func" >/dev/null ; then
					echo "Error: invalid line $REPLY"
					return 1
				fi

				# control first is service
				[ "$func" = "service" ] && found=1
				if [ $found -eq 0 ] ; then
					echo "Error: invalid line $REPLY"
					return 1
				fi

				# execute function
				$func $@
				if [ $? -ne 0 ] ; then
					echo "Error: invalid line  $REPLY"
					return 1
				fi
			else
				if [ "$func" = "service" ] ; then
					[ $found -eq 1 ] && return 0
					$func $@
					[ $? -eq 0 ] && found=1
				fi

				if [ $found -eq 1 ] ; then
					if [ -z "$func" -o -n "${func//[[:word:]]}" ] ||
					   ! declare -F "$func" >/dev/null ; then
						echo "Error: invalid line $REPLY"
						return 1
					fi

					$func $@
	                                if [ $? -ne 0 ] ; then
        	                                echo "Error: invalid line  $REPLY"
                	                        return 1
                        	        fi
				fi
			fi

		fi
	 done
        ) <$CONFIG

    [ "$?" != "0" ] && exit 1

    exit 0

}


# Dump configuration for edit
do_getconf() {
	local p=$1
	local instance=$2
	local tmpconfig="/tmp/$p${instance:+instance}.conf"

	[ -e "$tmpconfig" ] && cat "$tmpconfig" && return 0

	[ -z "$opt_config" -o ! -e "$opt_config" ] && echo "No configuration available!" >&2 &&  return 1

	cat "$opt_config"

	return 0
}

# Update and test edited configuration
do_checkconf() {
	local p=$1
	local instance=$2
	local tmpconfig="/tmp/$p${instance:+.$instance}.conf"
	local length=0
	local hread=0
	local ret

	if [ ! -t 0 ] ; then
	        eval $(
                        IFS=""
                        header="Content-length: "
                        while read line; do
                                [ -z "$line" ] && echo "hread=1" && exit 0
                                if [ "${line:0:${#header}}" = "$header" ] ; then
                                        echo -ne "length=${line:${#header}}; "
                                fi
                        done
                        exit 0
	        )

		if [ "$hread" = "1" ] ; then
			[ "$length" = "0" ] && echo "Invalid configuration" >&2 && return 1
       			cat > "$tmpconfig"
			[ ! -e "$tmpconfig" ] && echo "Unable to retrieve configuration" >&2 && return 1
			[ "$length" != "$( cat $tmpconfig | wc -c )" ] && echo "Truncated configuration" >&2 && return 1
		fi
	fi

	[ ! -e "$tmpconfig" ] && echo "Configuration not modified" >&2 && return 0
	ret=0
        declare -F fct_post_checkconf >/dev/null && { fct_post_checkconf "$p" "$instance" "$tmpconfig" ; ret=$?; }

	return $ret
}

# Cancel configuration edit
do_cancelconf() {
	local p=$1
	local instance=$2
	local tmpconfig="/tmp/$p${instance:+.$instance}.conf"
	rm -f "$tmpconfig" >/dev/null 2>&1

	return 0
}


# Update test and commit edited configuration
do_setconf() {
	local p=$1
        local instance=$2
	local tmpconfig="/tmp/$p${instance:+.$instance}.conf"

	do_checkconf $p $instance
	[ "$?" != "0" ] && return 1
	[ ! -e "$tmpconfig" ] && echo "No configuration to commit" >&2 && return 0
	[ -n "$opt_config" ] && mv "$tmpconfig" "$opt_config"

	return 0
}

do_autostart() {
	local svc=$1
	local instance=$2

	(
	local cur=0
	local written=0

	while : ; do
		read
		[ "$?" != "0" ] && [ -z "$REPLY" ] && break

		set -- $REPLY
		[ "$1" = "no" ] && shift ;

		if [ "$1" = "service" ] ; then
		[ $cur -eq 1 ] && [ "$written" = "0" ] && [ "$autostart" = "1" ] && echo "    no autostart" && echo ""
			echo "$REPLY"
			cur=0
			written=0
			if [ -n "$instance" ] ; then
				if [ "$2" = "$svc" -a "$3" = "$instance" ] ; then
					cur=1
				fi
			elif [ "$2" = "$svc" ] ; then
				cur=1 ;
			fi

		elif [ $cur -eq 1 ] ; then
			if [ -z "$1" ] ; then
				if [ "$written" = "0" -a "$autostart" = "1" ] ; then
					written=1
					echo "    no autostart"
				fi
				echo ""
			elif [  "$1" != "autostart" ] ; then
				echo "$REPLY"
			fi
		else
			echo "$REPLY"
		fi

	done
	exit 0 ) < $CONFIG >$CONFIG.new

	[ "$?" != "0" ] && return 1

	mv $CONFIG.new $CONFIG
}

# Get list of command for completion
fct_complete() {
    declare -F | while read d f cmd; do
	[ "${cmd#do_}" = "$cmd" ] && continue
	cmd=${cmd#do_}
	case $cmd in
	    complete) continue ;;
	    status_with_pidfile|stop_with_pidfile) continue ;;
	    cancelconf|checkconf|setconf) continue ;;
	    cancelsec|checksec|setsec|testsec) continue ;;
	esac
	echo $cmd
    done
}

do_complete() {
    fct_complete
}
 
# 'no' for 'no ... ', disable a service or an option
default_no() {
    local req=$1
    shift
    case "$req" in
	service|section|interface)
	    default_service
	    ;;
	*)
	    local opt=0
	    local var_name=svc_num_$req
	    opt=${!var_name}
	    if [ -z "$opt" ]; then
	        echo "Bad option '$req' in 'no $req $*'" >&2
		return
	    fi

	   if [ "${svc_fcts[$opt]}" != "multiple_option" ]; then
	           # in case of multiple_option, "no <option> <args>" only
	           # means that we don't want to add <args> to <option>,
	           # but not that we want to clear <option>.
	           eval "${svc_vars[$opt]}=''"
	   fi
    esac
}

# Parse the config parts passed on stdin. Empty lines as well as those
# beginning with # are ignored. Non-existing options are not reported
# when just listing sections.
parse_cfg() {
	local name res
	while read REPLY 2>/dev/null; do
		set -- $REPLY
		[ -z "${1##\#*}" -o -z "${1##.*}" ] && continue
		name=svc_num_$1; res=res_kwd_$1
		if [ -z "${!name}${!res}" ]; then
			echo "Bad option '$1' in '$REPLY'" >&2
			continue
		fi
		eval "${REPLY}"
	done
}

# Normalize the config parts passed on stdin.
norm_cfg() {
	awk '{ \
	      gsub("[[:space:]]*$", "", $0); \
	      if (substr($1,0,1)=="#") { print $0; next; } \
	      gsub("^[[:space:]]*", "", $0); \
	      if ($1 == "") next; \
	      if ($1=="no" && $2=="service" || $1=="service") { \
	          if (sec) print ""; \
	          print $0; sec=1; } \
	      else print "    " $0; \
	     } \
	     END { if (NR) print ""; }'
}

# source configuration file, called last.
load_config() {
    # defines functions for all first words in the config file
    res_kwd_no=1
    res_kwd_service=1
    res_kwd_section=1
    res_kwd_interface=1

    # We already know if the action is known or not, it's not necessary
    # to parse all the config to find that.
    if [ -z "$ACTION" -o -n "${ACTION//[[:word:]]}" ] ||
       ! declare -F do_$ACTION >/dev/null; then
	if declare -F do_help >/dev/null; then
	    do_help
	else
	    echo "Error: Unknown action : $ACTION" >&2
	fi
	STATUS_RET=1
	return $STATUS_RET
    fi

    # ACT_INTERNAL is set for internal actions.
    unset ACT_INTERNAL ACT_DONE
    case $ACTION in
	getsec|getconf|setsec|setconf|checksec|checkconf|cancelsec|cancelconf|testsec|autostart)
	    ACT_INTERNAL=set
	    ;;
    esac

    # defines functions for reserved keywords: no, service, section, interface.
    no() { default_no $*; }
    service() { default_service $*; }
    section() { default_service $*; }
    interface() {
	if [ "$PNAME" = "network" ]; then
	    echo "Warning: use of 'interface $1' keyword is deprecated. Use 'section network $1' instead." >&2
	fi
	default_service network $*;
    }

    if test ! -d "$CONFIG" -a -e "$CONFIG" ; then
	# first keywords out of a section space are for the system, so let's enter
	# automatically in system section.
	service system
	run_stdin parse_cfg <(awk -v pname="$PNAME" -v inst="$SVC_INSTANCE" '\
		    BEGIN{ if (pname=="system") inside=1} {\
		    if (substr($1,0,1)=="#") next; if ($1=="no" && $2=="service") inside=0;\
		    else if ($1=="service") {\
		      if ((pname==$2 || pname=="") && (inst==$3 || inst=="")) inside=1; else inside=0;}
		    if (inside) print $0;}' $CONFIG)
	service ""
    fi

    if [ "$SVC_FOUND" != 1 ]; then
	echo "Warning: service/instance not found in $CONFIG, using default values." >&2
	service $PNAME ; service ""

        #[ "x$G_FACILITY" != x ] && \
        #   $_LOGGER -p $G_FACILITY.warn -t "flxi[$$].$PNAME" -- \
        #     "unknown[$USER]: $PNAME $ACTION ${SVC_INSTANCE[*]}"
	#exit 1
    fi
    return $STATUS_RET
}

###################################################################
# Second half of main entry point. Declaration of default options #
###################################################################

# most services don't need to redefine the keywords "bin", "cmdline",
# "pidfile", "procname" and "check_interval", so let's initialize them now.
# This also means that any service can use these options without declaring them.
option	bin		reserved_option
option	cpumask		reserved_option
option	cmdline		reserved_option '$bin'
option	pidfile		reserved_option
option	procname	reserved_option
option	check_interval	reserved_option	0
option	autostart	reserved_bool_option	1

# return to caller (. functions) or exit in case of direct call
set -- $(caller 2>/dev/null)
if [ -z "$1" -o "$1" = 0 ]; then
   load_config
   exit 0
else
   return 0
fi
