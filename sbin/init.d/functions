#!/bin/bash

#
# sbin/init.d/functions - Formilux init script - version 0.3.31 - 2004-03-11
#
# Copyright (C) 2001-2003 Benoit Dolez & Willy Tarreau
#       mailto: benoit@ant-computing.com,willy@ant-computing.com
#
# This program is licenced under GPLv2 ( http://www.gnu.org/licenses/gpl.txt )

# Test for previous sourcing already in progress
declare -F reserved_bool_option > /dev/null && return

# SSHD starts this script with "-c" followed by all the parameters grouped into
# one single string. So we expand it to allow remote commands.
if [ "$1" = "-c" ]; then shift; set -- $*; fi

# Configuration file to use. Default : /etc/config.rc
export CONFIG=${CONFIG:-/etc/config.rc}

# Process name
if [ -z "${0##*/*}" ]; then
    PNAME="${0##*/}"
    PPATH="${0%/*}"
    PPATH="${PPATH:-/}"
else
    PNAME="$0"
    PPATH=.
fi
PFULLNAME=$0

# Path to startup scripts. Default : /sbin/init.d
# INIT_PATH=${INIT_PATH:-/sbin/init.d}
INIT_PATH=${INIT_PATH:-$PPATH}

# Global variable for status information. Set to "1" while processing the right
# section.
RUNNING_SECTION=

# goes "1" if at least one instance of the required service has been found
SVC_FOUND=

# not in list mode
MUST_LIST_SECTIONS=

# no option filter
OPTION_FILTER=

# signal to use at first when stopping a service. Default: TERM
# May be changed by any init script (eg: sshd)
STOP_FIRST_WITH=TERM

# set with --force to ignore current status
FORCE_START_STOP=0

# controls wether the service is being started with --auto
SVC_AUTO_START=0

# facility for syslog message
G_FACILITY=local3

# LOG FILE
LOGFILE=/var/log/startup.log
[ -L "$LOGFILE" ] && rm -f $LOGFILE
#[ -e "$LOGFILE" ] || touch $LOGFILE && chown root:adm $LOGFILE && chmod 0640 $LOGFILE

# the scripts can list some global variables which they use and that should be
# unset after processing the service. This is to be set globally.
SVC_VARS=

# this is set to $? for the first do_xxx which doesn't return 0
STATUS_RET=0

########################################
#           BASIC FUNCTIONS            #
########################################
logit() {
    # echo -n "'"
    # echo -n "$*" | sed -e "s/'/\\\\'/" -e "s/§/' '/g"
    # echo "'"
    echo "  $*"
    [ "${1##\#*}" -a "xG_FACILITY" != x ] && \
         logger -p $G_FACILITY.info -t "flxi[$$].$PNAME" -- \
           "exec[$USER]: $*"
    $*
    local return=$?
    [ $return != 0 -a "xG_FACILITY" != x ] && \
         logger -p $G_FACILITY.info -t "flxi[$$].$PNAME" -- \
           "exec.error[$USER]: $return"
    return $return
}

# returns the value for a given parameter in a config file. The value is both
# echoed and set to the REPLY variable.
# The value is found this way :
# [ \t]*<parameter>[:= \t]*<value>[#]*<comment>$

# usage: valueof CONFIGFILE PARAMETER
valueof() {
    if [ -e "$1" ]; then
        REPLY=$(sed -ne s,'^\('$'[ \t]*'"$2"$'[ \t:=]*''\)\([^#]*\).*$,\2,'p "$1")
    else
        REPLY=
    fi
    echo $REPLY
}

# returns children processes ids.
# usage: getchild PID ...
childrenpid() {
    local found
    local pid=" $* "

    set -- $( exec ps ahxo ppid,pid ) ; while [ $# -gt 0 ] ; do 
	    [ -z "${pid/* $1 */}" ] && found="$found $2" ; shift ; shift ; done

    REPLY="" && [ "$found" ] && REPLY=$found && echo $REPLY
}


# Returns process id from process name only by looking at the process table.
# (ie: no pidfile used). Only processes which have ppid of 1 (or parent_pid)
# are returned. A list of pids to omit can be specified with "-o".
# If no process name is specified, all the parent's children are returned.
# if "parent_pid" is empty, then the parent's pid is not checked.
# svc_pidof [ -o "omit_pids*" ]* [ -p parent_pid ] [ PNAME ... ]
svc_pidof() {
    local omit=x
    local ppid=1
    local comm
    local found

    while [ $# -gt 0 ] ; do
	if [ "x$1" = "x-o" ] ; then omit="$omit ${2/%PPID/$$} " ; shift 2
	elif [ "x$1" = "x-p" ] ; then ppid="$2" ; shift 2
	else comm="$comm $1 " ; shift 1
	fi
    done

    #set -- "$( exec ps ahxo pid,ppid,comm )" ; set -- $( echo "$1" | awk '{ print $1,$2,$3}' )
    set -- $( ps ahxo pid,ppid,comm | awk '{ print $1,$2,$3}' )
    while [ $# -gt 0 ] ; do 
	[ -z "${comm/* $3 */}" -a -n "${omit/* $1 */}" ] && [ -z "$ppid" -o "$2" = "$ppid" ] && found="$found $1" 
	shift ; shift ; shift
    done
    REPLY="" && [ "$found" ] && REPLY=$found && echo $REPLY
}

# This function starts the given process in background, in a new session,
# and with all its I/O directed to /dev/null, to ensure that it will not
# block a TTY if a lazy coder didn't think appropriate to close the file
# descriptors before forking.
daemon() {
    setsid "$@" </dev/null >&0 2>&0 &
}

# run command "$1" with $2=/dev/fd/XX on stdin.
run_stdin() {
	$1 <&${2##*/}
}

######################
# EXPORTED FUNCTIONS #
######################

# this eventually remounts the filesystem hosting the directory given in the
# argument read-write. 
# It returns :
#   - 0 if it was RO and has successfully been remounted RW
#   - 1 if it was already RW
#   - 2 if it could not be remounted RW

remount_rw() {
   local root
   set -- $(df $1|tail +2)
   root=$6
   set -- $(grep -v '^rootfs' /proc/mounts |cut -f2- -d' '|grep "^$root ")
   if [ "${3/rw//}" != "$3" ]; then
      return 1
   fi
   echo -n "    - remounting $root read-write ..."
   if remountw $root >/dev/null 2>&1; then
	echo "    => done."
	return 0
   else
	echo "    => failed."
	return 2
   fi
}

# this eventually remounts the filesystem hosting the directory given in the
# argument read-only. 
# It returns :
#   - 0 if it was RW and has successfully been remounted RO
#   - 1 if it was already RO
#   - 2 if it could not be remounted RO

remount_ro() {
   local root
   set -- $(df $1|tail +2)
   root=$6
   set -- $(grep -v '^rootfs' /proc/mounts |cut -f2- -d' '|grep "^$root ")
   if [ "${3/ro//}" != "$3" ]; then
      return 1
   fi
   echo -n "    - remounting $root read-only ..."
   if remountr $root >/dev/null 2>&1; then
	echo "    => done."
	return 0
   else
	echo "    => failed."
	return 2
   fi
}

# this will try to unload module $1 and all modules which depend on it
recursive_rmmod() {
    local -a args
    local mod

    while : ; do
	args=( $(/sbin/lsmod|tail +2|sed "s/([^)]*)//g"|grep "^$1 "|tr -d '\[\]') )
	[ ${#args[@]} -gt 0 ] || return 0
	if [ -n "${args[3]}" ]; then
	    # there are modules to unload first
	    mod=3
	    while [ $mod -lt ${#args[@]} ]; do
		if ! recursive_rmmod ${args[$mod]}; then
		    echo "Error: could not unload module ${args[$mod]}."
		    return 1
		fi
		(( mod++ ))
	    done
	elif [ "${args[2]}" = "0" ]; then
	    /sbin/rmmod $1
	    return $?
	else
	    # impossible to remove this module (count>0)
	    return 1
	fi
    done
}

########################################
# CONFIGURATION FILE LOADING FUNCTIONS #
########################################

# All functions handling options get the option name as a first argument,
# then the rest of the line follows.

# builtin function to create a variable from an option.
# The variable name is "opt_$option" where option is the option name.
standard_option() {
    if [ "x$2" = "x--disable" ]; then
	eval "opt_$1="
    else
	local name=$1 ; shift
	eval "opt_$name='$*'"
    fi
}

# builtin function to create a variable from an option.
# The variable name is "opt_$option" where option is the option name.
boolean_option() {
    if [ "x$2" = "x--disable" ]; then
	eval "opt_$1=0"
    else
	eval "opt_$1=1"
    fi
}

# builtin function to create a variable from an option.
# The variable name is the same as the option name.
# This is mainly used for reserved options such as "bin" and "cmdline",
# or to port older startup scripts.
# The option value is NOT evaluated now, which means that cmdline can refer to
# $bin if properly quoted. Eg: cmdline '$bin -f $config'
reserved_option() {
    if [ "x$2" = "x--disable" ]; then
	eval "$1="
    else
	eval "$1='$2'"
    fi
}

# builtin function to create a boolean variable from an option.
# The variable name is the same as the option name.
# This is mainly used for reserved options such as "autostart".
reserved_bool_option() {
    if [ "x$2" = "x--disable" ]; then
	eval "$1=0"
    else
	eval "$1=1"
    fi
}

# builtin function to create a variable from an option.
# The variable name is "opt_$option" where option is the option name.
long_option() {
    if [ "x$2" = "x--disable" ]; then
	eval "opt_$1="
    else
	local optname=$1
	shift
	eval "opt_$optname='$*'"
    fi
}

# builtin function to create an array from an option.
# The variable name is "opt_$option" where option is the option name.
# The array is extended with all the args for each occurence of the option.
# If no arg is given, the option is extended with a single dash '#' so that
# we further know that it has been called.
multiple_option() {
    if [ "x$2" = "x--disable" ]; then
	# in case of multiple_option, "no <option> <args>" only
	# means that we don't want to add <args> to <option>,
	# but not that we want to clear <option>
	# eval "opt_$1=( )"
	:
    else
	local optname=$1
	shift
	if [ $# -gt 0 ]; then
	    #eval "opt_$optname=( \$opt_$optname \"$*\" )"
	    eval "opt_$optname[\${#opt_$optname[*]}]='$*'"
	else
	    # if no option is set, this reference will be lost because in fact
	    # it will be added as an empty entry in the list. So we replace it
	    # with a dash '#' to mark it as referenced.
	    eval "opt_$optname[\${#opt_$optname[*]}]='#'"
	fi
    fi
}

# default start function
# usage : do_start process_name [instance_name]
# if functions fct_pre_start() and fct_post_start() are defined, they will be
# called just before and just after the cmdline.
do_start() {
    local p=$1
    local instname=$2
    local ret
    do_status $p $instname > /dev/null 2>&1
    if [ $? = 0  -a $FORCE_START_STOP -eq 0 ] ; then
	echo "Process $p${instname:+[$instname]} already running."
	[ $SVC_AUTO_START -eq 0 ] && echo "  ==> please use '--force' or 'restart' instead or check with 'status'."
	return 0
    fi

    echo "# Starting $p${instname:+[$instname]} ..."
    ret=0
    declare -F fct_pre_start >/dev/null && { fct_pre_start $p $instname ; ret=$?; }
    [ $ret -eq 0 ] && { logit $cmdline; ret=$?; }
    [ $ret -eq 0 ] && declare -F fct_post_start >/dev/null && { fct_post_start $p $instname; ret=$?; }
    [ $ret -eq 0 ] && echo "  ==> start $p${instname:+[$instname]} Done." || \
		    { echo "  ==> start $p${instname:+[$instname]} Failed." ; return 1 ; }
    return 0
}

#
# This function tries to stop the process whose pid is specified in the file
# in $1. It returns 0 if the process is stopped, or 1 if it is still running.
# There can be only one pid per pidfile.
#
# usage : do_stop_with_pidfile pidfile [process_name [instance_name]]
# if functions fct_pre_stop() and fct_post_stop() are defined, they will be
# called just before and just after a successful kill sequence.
do_stop_with_pidfile() {
    local pid
    local pids
    local pidfile=$1
    local pname=$2
    local instname=$3
    local ret

    svc_pidof -o $$ $pname > /dev/null ; pids=$REPLY
    
    if [ $FORCE_START_STOP -eq 0 ]; then
	if ! [ -r "$pidfile" ] || { read pid REPLY <"$pidfile"; [ -z "$pid" ]; } || ! [ -L /proc/$pid/cwd ]; then
	    echo "# Process $pname${instname:+[$instname]} already stopped (according to $pidfile)${pids:+, but check pids : $pids}"
	    # ensure that we remove stale files
	    [ -e "$pidfile" ] && echo "Removing stale pid file" && rm -f "$pidfile"
	    return 0
	fi
    fi

    valueof /proc/$pid/status Name >/dev/null ; set -- $REPLY
    if [ "$pname" -a "x$pname" != "x$1" -a $FORCE_START_STOP -eq 0 ]; then
	echo "# The pid in $pidfile points to a wrong process name ($pid:$1)${pids:+. Check $pids for $pname${instname:+[$instname]}}."
	return 1;
    fi
 
    echo "# Stopping $pname${instname:+[$instname]} (pid $pid according to $pidfile) ..."

    ret=0
    declare -F fct_pre_stop >/dev/null && { fct_pre_stop $pname $instname; ret=$?; }
    if [ $ret -eq 0 ]; then
	kill -CONT $pid >/dev/null 2>&1 ; kill -$STOP_FIRST_WITH $pid >/dev/null 2>&1

	set -- 0 1 2 3
	while [ -L /proc/$pid/cwd -a $# -gt 0 ] ; do
	    [ $# -eq 4 ] && echo -n '  Waiting.' || echo -n '.'
	    sleep $1
	    shift
	done
	[ $# -eq 4 ] || echo

	[ -L /proc/$pid/cwd ] && { kill -9 $pid >/dev/null 2>&1; sleep 1 ; }
	if [ ! -L /proc/$pid/cwd ]; then
	    if [ -e "$pidfile" ]; then
		echo "  --> removing stale pid file ..."
		rm -f "$pidfile"
	    fi
	else
	    ret=1
	fi
    fi
    [ $ret -eq 0 ] && declare -F fct_post_stop >/dev/null && { fct_post_stop $pname $instname; ret=$?; }
    [ $ret -eq 0 ] && echo "  ==> stop $pname${instname:+[$instname]} Done." || \
		    { echo "  ==> stop $pname${instname:+[$instname]} Failed." ; return 1; }
    return 0
}

#
# default stop function
# If a pidfile exists, it is used. Otherwise, all pids with same name which have
# init for parent will be killed.
# The function returns 0 if the process is(are) stopped, and 1 if not all could
# be stopped.
#
# usage : do_stop process_name [instance_name]
# if functions fct_pre_stop() and fct_post_stop() are defined, they will be
# called just before and just after a successful kill sequence.
do_stop() {
    local pname=$1
    local instname=$2
    local pid
    local retry
    local ret
    shift
 
    pname=${procname:-$pname}
    # stop service from pidfile 
    [ "x$pidfile" != x ] && { do_stop_with_pidfile $pidfile $pname $instname; return $? ; }

    # stop service from pidof data
    svc_pidof -o $$ $pname > /dev/null
    if [ -z "$REPLY" ]; then
	echo "# Process $pname${instname:+[$instname]} already stopped, cleaning up..."
	declare -F fct_post_stop >/dev/null && fct_post_stop $pname $instname
	echo "  ==> stop $pname${instname:+[$instname]} Done."
	return 0
    fi
    echo "# Stopping process $pname${instname:+[$instname]} (pids : $REPLY) ..."
    retry=$REPLY; # save it temporarily
    ret=0
    declare -F fct_pre_stop >/dev/null && { fct_pre_stop $pname $instname; ret=$?; }
    REPLY=$retry; retry=1
    if [ $ret -eq 0 ]; then
	while [ "$REPLY" ]; do
	    if [ $retry -le 3 ]; then
		kill -CONT $REPLY >/dev/null 2>&1 \
		  && kill -$STOP_FIRST_WITH $REPLY >/dev/null 2>&1 \
		    || break
		[ $retry -eq 1 ] && echo -n '  Waiting.' || echo -n '.'
		sleep $retry
	    elif [ $retry -eq 4 ]; then
		kill -9 $REPLY >/dev/null 2>&1 \
		  || break
		echo -n '[killing hard]'
		sleep 1
	    else
		ret=1
		break
	    fi
	    REPLY=`ps ho pid $REPLY`
	    retry=$[$retry+1]
	done
	[ $retry -gt 0 ] && echo
    fi

    retry=$REPLY; # keep a copy
    [ $ret -eq 0 ] && declare -F fct_post_stop >/dev/null && { fct_post_stop $pname $instname; ret=$?; }
    [ $ret -eq 0 ] && echo "  ==> stop $pname${instname:+[$instname]} Done." || \
		    { echo "  ==> stop $pname${instname:+[$instname]} Failed.${retry:+ (pids : $retry)}" ; return 1; }
    return 0
}

# reload only for started processes
do_reload_started() {
    
    if [ "x$pidfile" != x ] ; then
      kill -HUP $(<$pidfile)
    else
      do_restart "$@"

    fi
}

# we just want to reload service, default reload action is to restart
do_reload() {
    if do_status "$@" >/dev/null 2>&1 ; then
      do_reload_started "$@"
    else
      do_restart "$@"
    fi
}

# we *absolutely* want to restart the service, even if it's frozen as "defunct"
do_restart() {
    do_stop $* || ( FORCE_START_STOP=1 do_stop $* )
    do_start $*
}

# returns a basic check of the service, an returns one line of info of the form:
# <hostname> <service_name>.[instance_name] <date_in_secs>  {RUNNING|STOPPED}[,more_info] [{OK|CONFIG_CHANGED}]
# returns 0 if running.
do_check() {
    local run_stat
    local status=OK
    local ret uptime=0
    local pid

    do_status $1 $2 > /dev/null
    ret=$?
    if [ $ret -eq 0 ]; then
	if [ "$REPLY" ]; then
	    for pid in $REPLY; do
		uptime=$[$(date +%s)-$(date -d "`ps ho lstart $pid`" +%s)]
		echo "`uname -n` $1.$2 `date +%s` RUNNING $uptime $status"
	    done
	else
	    echo "`uname -n` $1.$2 `date +%s` RUNNING 0 $status"
	fi
    else
        run_stat=STOPPED
	case $ret in
	    1)  status=ALERT,nofile ;;
	    2)  status=ALERT,nopid  ;;
	    3)  status=ALERT,other  ;;
	    *)  status=ALERT        ;;
	esac
	echo "`uname -n` $1.$2 `date +%s` $run_stat $uptime $status"
    fi
    return $ret
}

# returns 0 if the process is running, 1 if the pid file does not exist,
# 2 if the pid doesn't exist anymore, 3 if it has been affected to another
# process name. If the process is running, REPLY is set to its pid.
# usage : do_status_with_pidfile pidfile [process_name [instance_name]]
do_status_with_pidfile() {
    local pidfile=$1
    local pname=$2
    local instname=$3
    local pid

    [ -r "$pidfile" ] || { echo "Process $pname${instname:+[$instname]} stopped (no pidfile present)" ; return 1 ; }
    read pid < $pidfile
    [ -L /proc/$pid/cwd ] || { echo "Process $pname${instname:+[$instname]} stopped (from pidfile)" ; return 2 ; }
    valueof /proc/$pid/status Name >/dev/null ; set -- $REPLY
    [ "$pname" -a "x$pname" = "x$1" ] || {
	echo "Process with an other name ($1,$pid) already running."
	echo "  ==> you should remove invalid pidfile $pidfile"
	return 3
    }
    childrenpid $pid > /dev/null
    local cpid=$*
    echo "Process $pname${instname:+[$instname]} running : $pid ${cpid:+($cpid)}"
    REPLY=$pid
    return 0
}

# returns 0 if the process is running; 1 if it's stopped and there's no pid file,
# otherwise same as do_status_with_pidfile(). If the process is running, REPLY is
# set to its pid.
# usage : do_status process_name [instance_name]
do_status() {
    local pname=$1
    local instname=$2
    shift

    pname=${procname:-$pname}
    # get info from pidfile if it exist 
    [ "x$pidfile" != x ] && { do_status_with_pidfile $pidfile $pname $instname; return $? ; }
    
    # get info from pidof command
    svc_pidof -o $$ $pname > /dev/null ; pids=$REPLY
    [ "$pids" ] && { echo "Process $pname${instname:+[$instname]} running without pidfile : $pids" ; return 0 ; }
    echo "Process $pname${instname:+[$instname]} stopped (no pidfile used)."
    return 1
}

# lists all the known options for the current service, with their default or
# assigned values. There is a double eval so that options depending on others
# are correctly resolved.
# The output format is "process_name.[instance_name] option value"
# usage : list_options process_name [instance_name]
do_list_options() {
    local i=0
    local occur=0
    local nbocc=0
    local inst="$1.$2"

    while [ $i -lt $svc_nbopts ]; do
	if [ -z "$OPTION_FILTER" -o "$OPTION_FILTER" = "${svc_opts[$i]}" ]; then


	    if [ "${svc_fcts[$i]}" = "boolean_option" -o \
		 "${svc_fcts[$i]}" = "standard_option" -o \
		 "${svc_fcts[$i]}" = "long_option" -o \
		 "${svc_fcts[$i]}" = "reserved_bool_option" -o \
		 "${svc_fcts[$i]}" = "reserved_option" ]; then
		    eval eval echo $inst ${svc_opts[$i]} \$"${svc_vars[$i]}"
	    elif [ "${svc_fcts[$i]}" = "multiple_option" ]; then
		eval nbocc='${#'"${svc_vars[$i]}"'[*]}'
		occur=0
		if [ $nbocc -eq 0 ]; then # no value, let's at least show the option name
		    eval echo $inst ${svc_opts[$i]}
		else
		    while [ $occur -lt $nbocc ]; do
			eval eval echo $inst ${svc_opts[$i]} '${'"${svc_vars[$i]}"'[$occur]}'
			occur=$[$occur+1]
		    done
		fi
	    else
		echo $inst ${svc_opts[$i]} "[defined by script]"
	    fi
	fi
	i=$[$i+1]
    done
}

# maps an option to a function. Existing options are simply overridden.
# usage: option option_name function_name [ defaults ]
option() {
    local name=$1
    local fct=$2
    local def=$3
    local opt=0
    local var_name=svc_num_$1

    # first, check if this option has already been defined, and return its
    # index, or a new one if it's new.
    opt=${!var_name}
    if [ -z "$opt" ]; then
	opt=$((svc_nbopts++))
	eval $var_name=$opt
    fi

    svc_opts[$opt]=$name
    svc_fcts[$opt]=$fct
    svc_defs[$opt]=$def
    if [ "x$fct" = "xboolean_option" -o "x$fct" = "xstandard_option" -o \
	 "x$fct" = "xlong_option" -o "x$fct" = "xmultiple_option" ]; then
	svc_vars[$opt]=opt_$name
    elif [ "x$fct" = "xreserved_option" -o \
           "x$fct" = "xreserved_bool_option" ]; then
	svc_vars[$opt]=$name
    else
	svc_vars[$opt]=""
    fi
}

# default 'service' function.
# Called as default_service svc_name [svc_instance] from load_config.
# SVC_ARGS is set from the service command line, and is used at next one.
default_service() {
    local ret
    local opt
    local val
    # skip first parameter (probably 'service')
    #shift  

    # we're in listing mode, we do nothing except listing the services
    if [ "$MUST_LIST_SECTIONS" = 1 -a $# -ge 1 ]; then
	[ "$1" != "${SVC_ARGS[0]}" -o "$2" != "${SVC_ARGS[1]}" ] && echo $*
	SVC_ARGS=( $* )
	return
    fi

    # check for running selected service. We generally start in previous section.
    if [ "$RUNNING_SECTION" = 1 ]; then
	# first, we'll check wether the next service is *exactly* the same as
	# the current one, in which case they are merged, in order to avoid
	# duplicate starts (system for example)
	if [ "$PNAME" = "$1" -a "${SVC_ARGS[0]}" = "$2" ]; then
	    return
	fi

	# try to insert command-line options
	while [ "$FORCE_OPTIONS" ]; do  # "opt=val,opt=val..."
	    opt=${FORCE_OPTIONS%%,*}
	    val=${opt#*=}
	    opt=${opt%%=*}
	    eval $opt $val
	    if [ "${FORCE_OPTIONS%%*,*}" ]; then # no more ','
		break;
	    else
		FORCE_OPTIONS=${FORCE_OPTIONS#*,}
	    fi
	done

	# unset all functions which handle options to avoid conflicts with
	# commands (eg: modprobe, ip ...)
	unset -f ${svc_opts[*]}

	declare -F set_vars > /dev/null && set_vars
	# force a last eval on each reserved option so that they can refer to
	# each other.
	for i in bin pidfile procname cmdline; do eval eval "$i=\\\"\$$i\\\""; done

	# now if the script defines a fct_end_section() function, let's call
	# it to fix some values, or extract som from external config files.
	declare -F fct_end_section > /dev/null && fct_end_section $PNAME ${SVC_ARGS[*]}

	ret=0
	if [ "$SVC_AUTO_START" = 0 -o "$autostart" = 1 ]; then
	    if declare -f do_$ACTION >/dev/null; then
		case $ACTION in
			getsec|getconf|setsec|setconf|checkconf|checksec|testsec|autostart)
				if [ "x${SVC_INSTANCE[0]}" = "x" ] ; then
				# if no instances in args, execute do_$ACTION
				# only one time for those actions
					do_$ACTION $PNAME 
					ret=$?
					unset -f do_$ACTION
				else
				# else process as std case
					do_$ACTION $PNAME ${SVC_ARGS[*]}
					ret=$?
				fi
				;;
			*) 
				# std case
				do_$ACTION $PNAME ${SVC_ARGS[*]}
				ret=$?
				;;
		esac

	    else
		case $ACTION in
			getsec|getconf|setsec|setconf|checkconf|checksec|testsec|autostart) ;;
			*)
				if declare -f do_help >/dev/null; then
				    	do_help
				else
		   			echo "Error: Unknown action : $ACTION"
				fi
				((0))  # report an error
				ret=$?
				;;
		esac
	    fi
	fi

	if [ $ret -gt 0 ]; then
	    STATUS_RET=$ret
	fi

        if [ "x$G_FACILITY" != x ] ; then
          if [ "x$ACTION" = xstart -o "x$ACTION" = xstop \
               -o "x$ACTION" = xrestart ] ; then 
            if [ $ret -gt 0 ] ; then
              logger -p $G_FACILITY.err -t flxi[$$].$PNAME -- \
                  "error[$USER]: $PNAME $ACTION ${SVC_INSTANCE[*]} = $ret"
            else
              logger -p $G_FACILITY.info -t flxi[$$].$PNAME -- \
                  "done[$USER]: $PNAME $ACTION ${SVC_INSTANCE[*]}"
            fi 
          fi
        fi
	unset -v RUNNING_SECTION SVC_ARGS bin cmdline pidfile procname $SVC_VARS
    fi

    # if service is the one wished, start it at the end
    # Note that for the first and last sections, it will be different, so we still
    # need this test.
    if test "x$1" = "x$PNAME" -a \
	    \( "x$2" = "x${SVC_INSTANCE[0]}" -o "x${SVC_INSTANCE[0]}" = "x" \) ; then
	# we can test difference between SVC_ARGS and SVC_INSTANCE
	local include_default=""
	SVC_FOUND=1
	RUNNING_SECTION=1
	shift
	SVC_ARGS=( $* )

	# reset every variable
	unset -v ${svc_vars[*]}

	# map all options to their functions, and set default vars.
	i=0
	while [ $i -lt $svc_nbopts ]; do
	    eval "${svc_opts[$i]}() { ${svc_fcts[$i]} ${svc_opts[$i]} \$* ; }"
	    if [ "${svc_vars[$i]}" ]; then
		if [ "x${svc_fcts[$i]}" != "xmultiple_option" ]; then
		    eval "${svc_vars[$i]}='${svc_defs[$i]}'"
		else
		    eval "${svc_vars[$i]}=( )"
		fi
	    fi
	    i=$[$i+1]
	done

	include_default="/etc/default/$PNAME${SVC_ARGS[0]:+.${SVC_ARGS[0]}}"
	[ -f "$include_default" ] && parse_cfg < $include_default

	# now if the script defines a fct_begin_section() function, let's call
	# it to preset some default values from external config files.
	unset -v $SVC_VARS
	declare -F fct_begin_section > /dev/null && fct_begin_section $PNAME ${SVC_ARGS[*]}
    fi
}

# Prepare section(s) for edit 
do_getsec() {
	local svc=$1;
        local instance=$2;
	local tmpconfig="/tmp/$svc${instance:+.$instance}.sec"

	[ -e "$tmpconfig" ] && cat "$tmpconfig" && return 0
	
	(
	local print=0
	
	while : ; do
		read
		eof=$?
		[ "$eof" != "0" ] && [ -z "$REPLY" ] && break

		set -- $REPLY	
		[ "$1" = "no" ] && shift ;
		
                if [ "$1" = "service" ] ; then
			print=0
			if [ -n "$instance" ] ; then
				[ "$2" = "$svc" -a "$3" = "$instance" ] && print=1
			else
				[ "$2" = "$svc" ] && print=1
			fi
                fi
		[ $print -eq 1 ] && echo "$REPLY"

		[ "$eof" != "0" ] && echo ""

        done 
	exit 0 ) < $CONFIG 

        return 0 
}

# Insert edited section(s) 
do_setsec() {
	local svc=$1
        local instance=$2
	local tmpconfig="/tmp/$svc${instance:+.$instance}.sec"
	
	do_checksec $svc $instance
	[ "$?" != "0" ] && return 1 

        (
        local print=1
	local found=0

        while : ; do
               
		read
		eof=$?
		[ "$eof" != "0" ] && [ -z "$REPLY" ] && break 
		set -- $REPLY
                [ "$1" = "no" ] && shift ;

                if [ "$1" = "service" ] ; then
                        print=1
                        if [ -n "$instance" -a $found -eq 0 ] ; then
                                if [ "$2" = "$svc" -a "$3" = "$instance" ] ; then
					cat "$tmpconfig" | grep -vE '^($|( |	)*$'
					echo ""
					found=1
					print=0
				fi
                        elif [ $found -eq 0 ] ; then 
                                if [ "$2" = "$svc" ] ; then
					cat "$tmpconfig" | grep -vE '^( |	)*$'
					echo ""
					found=1
					print=0
				fi
                        elif [ -z "$instance" ] ; then
				if [ "$2" = "$svc" ] ; then
					print=0
				fi
			fi
                fi
                [ $print -eq 1 ] && echo "$REPLY"
		# config rc need returns on last line
		[ "$eof" != "0" ] && echo ""

        done 
	exit 0
	) < $CONFIG >$CONFIG.new

	if [ "$?" != "0" ] ; then
		rm -f $CONFIG.new >/dev/null 2>&1
		return 1
	fi

	mv "$CONFIG.new" "$CONFIG"
	rm -f "$tmpconfig"

        return 0
}

# Update and test edited section
do_checksec() {
	local svc=$1
	local instance=$2
	local tmpconfig="/tmp/$svc${instance:+.$instance}.sec"
	local length=0
	local test;

	if [ ! -t 0 ] ; then 
	        eval $(
                        IFS=""
                        header="Content-length: "
                        while read line; do
                                if [ -z "$line" ] ; then
                                        exit 0
                                elif [ "${line:0:${#header}}" = "$header" ] ; then
                                        echo -ne "length=${line:${#header}}; "
                                fi
                        done
                        exit 0
      		)
		
		if [ "$length" != "0" ] ; then
	       		cat > "$tmpconfig"
			[ ! -e "$tmpconfig" ] && echo "Unable to retrieve configuration" >&2 && return 1

			[ "$length" != "$( cat $tmpconfig | wc -c )" ] && echo "Truncated configuration" >&2 && return 1
		fi
	fi 

	[ ! -e "$tmpconfig" ] && echo "Configuration not modified" >&2 && return 0 
	( $INIT_PATH/$svc -f $tmpconfig testsec $instance >&2 )
	[ "$?" != "0" ] && return 1
	
	return 0 
}


# Cancel section(s) edit
do_cancelsec() {
	local svc=$1
	local instance=$2
	local tmpconfig="/tmp/$svc${instance:+.$instance}.sec"

	rm -f "$tmpconfig" 2>/dev/null 2>&1

	return 0
}

# function to test sections on -f <config>
# unknown option for service or other services are reported as errors
do_testsec() {
	local svc=$1
	local instance=$2

        for func in $DEFINED_FUNCTIONS ; do unset -f $func ; done
	i=0 
	while [ $i -lt $svc_nbopts ]; do
         	eval "function ${svc_opts[$i]} { ${svc_fcts[$i]} ${svc_opts[$i]} \$* ; } "	
  		i=$[$i+1]
	done

	eval "function service { [ "x\$1" != "x$svc" ] && return 1 ; [ "x$instance" != "x" -a "x$instance" != "x\$2" ] && return 1 ; return 0 ; } "

	(
	  local func
    	  local found=0
 
          while : ; do

		read
		[ "$?" != "0" ] && [ -z "$REPLY" ] && break
		set -- $REPLY

       		if [ -n "$1" -a "${1:0:1}" != "#" ] ; then
	
			[ "$1" = "no" ] && shift ;
			func="$1" ; shift;

			if [ "$IGNORE_OTHERS" = "" ] ; then
			# control if first work correspond to function
				if ! eval "declare -F $func >/dev/null" ; then
					echo "Error: invalid line $REPLY"
					return 1
				fi

				# control first is service
				[ "$func" = "service" ] && found=1
				if [ $found -eq 0 ] ; then
					echo "Error: invalid line $REPLY"
					return 1
				fi
			
				# execute function	
				$func $@
				if [ $? -ne 0 ] ; then
					echo "Error: invalid line  $REPLY"
					return 1
				fi
			else
				if [ "$func" = "service" ] ; then
					[ $found -eq 1 ] && return 0
					$func $@
					[ $? -eq 0 ] && found=1
				fi

				if [ $found -eq 1 ] ; then
					if ! eval "declare -F $func >/dev/null" ; then
						echo "Error: invalid line $REPLY"
						return 1
					fi

					$func $@
	                                if [ $? -ne 0 ] ; then
        	                                echo "Error: invalid line  $REPLY"
                	                        return 1
                        	        fi
				fi
			fi
				
		fi
	 done
        ) <$CONFIG
  
    [ "$?" != "0" ] && exit 1 

    exit 0 

}


# Dump configuration for edit 
do_getconf() {
	local p=$1
	local instance=$2
	local tmpconfig="/tmp/$p${instance:+instance}.conf"

	[ -e "$tmpconfig" ] && cat "$tmpconfig" && return 0

	[ -z "$opt_config" -o ! -e "$opt_config" ] && echo "No configuration available!" >&2 &&  return 1

	cat "$opt_config" 

	return 0
}

# Update and test edited configuration
do_checkconf() {
	local p=$1
	local instance=$2
	local tmpconfig="/tmp/$p${instance:+.$instance}.conf"
	local length=0


	if [ ! -t 0 ] ; then 
	        eval $(
                        IFS=""
                        header="Content-length: "
                        while read line; do
                                if [ -z "$line" ] ; then
                                        exit 0
                                elif [ "${line:0:${#header}}" = "$header" ] ; then
                                        echo -ne "length=${line:${#header}}; "
                                fi
                        done
                        exit 0
	        )
	
	        if [ "$length" != "0" ] ; then 
	      		cat > "$tmpconfig"
			[ ! -e "$tmpconfig" ] && echo "Unable to retrieve configuration" >&2 && return 1

			[ "$length" != "$( cat $tmpconfig | wc -c )" ] && echo "Truncated configuration" >&2 && return 1
		fi
	fi

	[ ! -e "$tmpconfig" ] && echo "Configuration not modified" >&2 && return 0 
	ret=0
        declare -F fct_post_checkconf >/dev/null && { fct_post_checkconf "$p" "$instance" "$tmpconfig" ; ret=$?; }

	return $ret 
}

# Cancel configuration edit
do_cancelconf() {
	local p=$1
	local instance=$2
	local tmpconfig="/tmp/$p${instance:+.$instance}.conf"
	rm -f "$tmpconfig" 2>/dev/null 2>&1

	return 0
}


# Update test and commit edited configuration
do_setconf() {
	local p=$1
        local instance=$2
	local tmpconfig="/tmp/$p${instance:+.$instance}.conf"

	do_checkconf $p $instance
	[ "$?" != "0" ] && return 1

	[ -n "$opt_config" ] && mv "$tmpconfig" "$opt_config"

	return 0
}

do_autostart() {
	local svc=$1
	local instance=$2

	(
	local cur=0
	local written=0

	while : ; do
		read
		[ "$?" != "0" ] && [ -z "$REPLY" ] && break

		set -- $REPLY
		[ "$1" = "no" ] && shift ;

		if [ "$1" = "service" ] ; then
		[ $cur -eq 1 ] && [ "$written" = "0" ] && [ "$autostart" = "1" ] && echo "    no autostart" && echo ""
			echo "$REPLY"
			cur=0
			written=0
			if [ -n "$instance" ] 
				if [ "$2" = "$svc" -a "$3" = "$instance" ] ; then
					cur=1
				fi
			elif [ "$2" = "$svc" ] ; then
				cur=1 ;
			fi

		elif [ $cur -eq 1 ] ; then
			if [ -z "$1" ] ; then
				if [ "$written" = "0" -a "$autostart" = "1" ] ; then
					written=1
					echo "    no autostart"
				fi
				echo "" 
			elif [  "$1" != "autostart" ] ; then
				echo "$REPLY" 
			fi
		else
			echo "$REPLY" 
		fi

	done
	exit 0 ) < $CONFIG >$CONFIG.new

	[ "$?" != "0" ] && return 1

	mv $CONFIG.new $CONFIG
}


# 'no' for 'no ... ', disable a service or an option
default_no() {
    local req=$1
    shift
    case "$req" in
	"service")
	    default_service
	    ;;
	"section")
	    default_service
	    ;;
        "interface")
	    default_service
	    ;;
	*)
	    if [ "$MUST_LIST_SECTIONS" = 1 ]; then
		return
	    fi

	    local opt=0
	    local var_name=svc_num_$req
	    opt=${!var_name}
	    if [ -z "$opt" ]; then
	        echo "Bad option '$req' in 'no $req $*'"
		return
	    fi

	   if [ "${svc_fcts[$opt]}" != "multiple_option" ]; then
	           # in case of multiple_option, "no <option> <args>" only
	           # means that we don't want to add <args> to <option>,
	           # but not that we want to clear <option>.
	           eval "${svc_vars[$opt]}=''"
	   fi
    esac
}

# Parse the config parts passed on stdin. Empty lines as well as those
# beginning with # are ignored. Non-existing options are not reported
# when just listing sections.
parse_cfg() {
	local name res
	while read REPLY 2>/dev/null; do
		set -- $REPLY
		[ -n "${1##\#*}" ] || continue
		name=svc_num_$1; res=res_kwd_$1
		if [ -z "${!name}${!res}" ]; then
			[ "$MUST_LIST_SECTIONS" = 1 ] || echo "Bad option '$1' in '$REPLY'"
			continue
		fi
		eval "${REPLY}"
	done
}

# source configuration file, called last.
load_config() {
    # defines functions for all first words in the config file
    res_kwd_no=1
    res_kwd_service=1
    res_kwd_section=1
    res_kwd_interface=1

    # defines functions for reserved keywords: no, service, section, interface.
    no() { default_no $*; }
    service() { default_service $*; }
    section() { default_service $*; }
    interface() {
	if [ "$PNAME" = "network" ]; then
	    echo "Warning: use of 'interface $1' keyword is deprecated. Use 'section network $1' instead.";
	fi
	default_service network $*;
    }

    if test ! -d "$CONFIG" -a -e "$CONFIG" ; then 
	# first keywords out of a section space are for the system, so let's enter
	# automatically in system section.
	service system
	run_stdin parse_cfg <(awk -v pname="$PNAME" -v inst="$SVC_INSTANCE" '\
		    BEGIN{ if (pname=="system") inside=1} {\
		    if (substr($1,0,1)=="#") next;if ($1=="service") {\
		      if ((pname==$2 || pname=="") && (inst==$3 || inst=="")) inside=1; else inside=0;}
		    if (inside) print $0;}' $CONFIG)
	service ""
    fi

    if [ "$SVC_FOUND" != 1 -a "$MUST_LIST_SECTIONS" != 1 ]; then
	echo "Warning: service/instance not found in $CONFIG, using default values."
	service $PNAME ; service ""

        #[ "x$G_FACILITY" != x ] && \
        #   logger -p $G_FACILITY.warn -t "flxi[$$].$PNAME" -- \
        #     "unknown[$USER]: $PNAME $ACTION ${SVC_INSTANCE[*]}"
	#exit 1
    fi
    return $STATUS_RET
}

# abort the process after displaying an error message.
die() {
    echo $* >&2
    exit 1
}

##################################
#   ALWAYS LOADED WHEN SOURCED   #
##################################

svc_opts=( )
svc_vars=( )
svc_defs=( )
svc_fcts=( )
svc_nbopts=0
unset ${!svc_num_*} ${!res_kwd_*}

while [ $# -gt 0 ] ; do
    case "$1" in
    -f|--file)	# use this configuration file
	export CONFIG=$2
	shift 2 || die "Error: missing arg for --file, try --help."
	;;
    --auto)	# only start services which don't have a "no autostart" statement
	SVC_AUTO_START=1
	shift
	;;
    --force)	# force start or stop disregarding current status
	FORCE_START_STOP=1
	shift
	;;
    --list_sections)	# list all known sections
	PNAME=""
	MUST_LIST_SECTIONS=1
	load_config
	exit 0
	;;
    --filter_option)	# display only this option in list_options
	OPTION_FILTER=$2
	shift 2 || die "Error: missing arg for --filter_option, try --help."
	;;
    -o|--option)	# force options : -o "opt=val,opt=val..."
	FORCE_OPTIONS=$2
	shift 2 || die "Error: missing arg for --option, try --help."
	;;
    -*)
	echo "Common commands : start, stop, restart, status, check, list_options."
	echo "Global options :"
	grep $'^[ \t]*-[-a-z0-9_|]*)[ \t]*# ' $PPATH/functions | \
	    sed -e $'s/^\\([ \t]*\\)\\([^)]*\\)\\([ \t#)]*\\)\\(.*\\)/    \\2\t\t\\4/'
	echo "Other options :"
	declare -F usage > /dev/null && usage $* || \
	    echo "    -h|--help		display this help" && \
		[ "x$USAGE" != x ] && echo "$USAGE"
	exit 1
	;;
    *)
	break 
	;;
    esac
done

# Assign the requested action to ACTION (first arg). Default : start
ACTION=${1:-start}; shift

# Assign the requested instances to SVC_INSTANCE. Default : ""
SVC_INSTANCE=( $* )

# most services don't need to redefine the keywords "bin", "cmdline",
# "pidfile", "procname" and "check_interval", so let's initialize them now.
# This also means that any service can use these options without declaring them.
option	bin		reserved_option
option	cmdline		reserved_option '$bin'
option	pidfile		reserved_option
option	procname	reserved_option
option	check_interval	reserved_option	0
option	autostart	reserved_bool_option	1

return 0

######### end of script, here comes some documentation #########

When a service is started, these operations are performed for each section
containing the same name, and the same instance name if any, or any instance if
no name is set :

  - options variables are initialized to their default values
  - if fct_begin_section() exists, it is called with service name and instance name
  - options are interpreted
  - bin,pidfile,cmdline,procname are converted through an eval so that they can
    reference variables options with '$name' or '$opt_name'.
  - if fct_end_section() exists, it is called with service name and instance name
  - if do_start() exists, it is called with service name and instance name.
    Otherwise, the default do_start() function is called with same args. This
    function calls fct_pre_start() with same args if it exists, just before
    starting $cmdline, and then fct_post_start() just after. Please note that
    fct_{pre,post}_start() must return 0 if they succeed, otherwise they will
    report a failure to start the service.

In case of a stop, everything is the same except do_start() which is replaced
with do_stop(). This last one also calls fct_pre_stop() and fct_post_stop(),
but this last one only if the stop is successful.

If the service is started as "service --auto start", the option "autostart" is
checked, and if set to 0, the service will not start. This is useful to
differentiate between configured services and enabled services.
